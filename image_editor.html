<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Editor - LocalForge</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Global Styles -->
    <link rel="stylesheet" href="css/style.css">
    <style>
        body {
            overflow: hidden;
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: {
                            850: '#1e293b',
                        }
                    }
                }
            }
        }
    </script>
    <!-- Custom Components -->
    <script type="module" src="js/components.js"></script>
</head>

<body
    class="bg-slate-50 dark:bg-slate-900 text-slate-900 dark:text-slate-200 font-sans h-screen flex overflow-hidden transition-colors duration-300">

    <local-sidebar></local-sidebar>

    <div class="flex-1 flex flex-col min-w-0">
        <!-- Header -->
        <local-header title="Image Editor">
            <i slot="icon" class="fas fa-image text-blue-500"></i>
            <div slot="actions" class="text-xs text-slate-500 dark:text-slate-400">16:9 Crop & Watermark Removal</div>
        </local-header>

        <!-- Main Content -->
        <div class="flex-1 flex overflow-hidden">

            <!-- Left Sidebar: File List -->
            <aside
                class="w-64 bg-white dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 flex flex-col shrink-0 z-10 transition-colors duration-300">
                <div class="p-4 border-b border-slate-200 dark:border-slate-700">
                    <h3 class="text-sm font-bold text-slate-500 dark:text-slate-400 mb-3 uppercase tracking-wider">
                        Explorer
                    </h3>
                    <div class="flex gap-2 mb-2">
                        <button id="btn-single"
                            class="flex-1 px-3 py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded text-xs text-slate-700 dark:text-white transition border border-slate-200 dark:border-slate-600 hover:border-slate-300 dark:hover:border-slate-500">üìÑ
                            File</button>
                        <button id="btn-input"
                            class="flex-1 px-3 py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded text-xs text-slate-700 dark:text-white transition border border-slate-200 dark:border-slate-600 hover:border-slate-300 dark:hover:border-slate-500">üìÇ
                            Folder</button>
                    </div>
                    <button id="btn-output"
                        class="w-full px-3 py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded text-xs text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition border border-slate-200 dark:border-slate-600 hover:border-slate-300 dark:hover:border-slate-500 hidden mb-1">üíæ
                        Choose Output Folder</button>
                    <div id="output-info" class="text-[10px] text-slate-500 truncate mt-1">Default: Downloads</div>
                </div>

                <ul id="file-list" class="flex-1 overflow-y-auto p-2 space-y-1">
                    <li
                        class="p-4 text-center text-slate-400 dark:text-slate-500 text-xs border border-dashed border-slate-300 dark:border-slate-700 rounded select-none">
                        Please select files or folder</li>
                </ul>

                <div class="p-2 border-t border-slate-200 dark:border-slate-700 text-center text-[10px] text-slate-400 dark:text-slate-500"
                    id="file-count">0 images
                </div>
            </aside>

            <!-- Center: Canvas -->
            <main
                class="flex-1 bg-slate-50 dark:bg-slate-900/50 flex flex-col relative overflow-hidden transition-colors duration-300">
                <!-- Filename Display -->
                <div id="filename-bar"
                    class="h-10 bg-white dark:bg-slate-800/90 border-b border-slate-200 dark:border-slate-700 flex items-center justify-center px-4 shrink-0 transition-colors duration-300">
                    <span id="current-filename"
                        class="text-sm font-medium text-blue-600 dark:text-blue-400 truncate max-w-full">No file
                        selected</span>
                </div>
                <div
                    class="flex-1 flex items-center justify-center p-8 overflow-hidden bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTAgMGgxMHYxMEgwem0xMCAxMGgxMHYxMEgxMHoiIGZpbGw9IiMzMzMiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+')] dark:bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTAgMGgxMHYxMEgwem0xMCAxMGgxMHYxMEgxMHoiIGZpbGw9IiMzMzMiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+')]">
                    <div id="canvas-wrapper"
                        class="relative shadow-2xl shadow-black/20 dark:shadow-black/50 border border-slate-200 dark:border-slate-700/50 bg-[#f0f0f0] dark:bg-[#111]">
                        <canvas id="main-canvas" class="block max-w-full max-h-[75vh]"></canvas>
                        <canvas id="interaction-layer"
                            class="absolute top-0 left-0 w-full h-full cursor-crosshair touch-none"></canvas>
                    </div>
                </div>

                <!-- Toast -->
                <div id="toast"
                    class="absolute top-14 left-1/2 -translate-x-1/2 bg-white dark:bg-slate-800 text-slate-800 dark:text-white px-4 py-2 rounded-full text-xs shadow-xl border border-slate-200 dark:border-slate-700 hidden transition-opacity z-50 flex items-center gap-2">
                    <i class="fas fa-info-circle text-blue-500 dark:text-blue-400"></i> <span>Notification</span>
                </div>
            </main>

            <!-- Right Toolbar -->
            <aside
                class="w-64 bg-white dark:bg-slate-800 border-l border-slate-200 dark:border-slate-700 flex flex-col shrink-0 overflow-y-auto z-10 transition-colors duration-300">
                <div class="p-3 space-y-4">

                    <!-- Crop Mode - Horizontal Layout -->
                    <div class="space-y-2">
                        <h4 class="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider">Mode
                        </h4>
                        <div class="flex gap-2">
                            <label class="flex-1 cursor-pointer">
                                <input type="radio" name="crop-mode" value="pad" checked class="hidden peer">
                                <div
                                    class="py-2 text-center text-xs font-medium text-slate-500 dark:text-slate-400 bg-slate-100 dark:bg-slate-900/50 border border-slate-200 dark:border-slate-700/50 rounded-lg peer-checked:bg-blue-100 dark:peer-checked:bg-blue-600/20 peer-checked:border-blue-500 peer-checked:text-blue-600 dark:peer-checked:text-blue-400 transition">
                                    Pad
                                </div>
                            </label>
                            <label class="flex-1 cursor-pointer">
                                <input type="radio" name="crop-mode" value="crop" class="hidden peer">
                                <div
                                    class="py-2 text-center text-xs font-medium text-slate-500 dark:text-slate-400 bg-slate-100 dark:bg-slate-900/50 border border-slate-200 dark:border-slate-700/50 rounded-lg peer-checked:bg-blue-100 dark:peer-checked:bg-blue-600/20 peer-checked:border-blue-500 peer-checked:text-blue-600 dark:peer-checked:text-blue-400 transition">
                                    Crop
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Gemini Auto Watermark Removal -->
                    <div class="space-y-2">
                        <h4 class="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider">Gemini
                            Watermark Removal</h4>
                        <button id="btn-gemini-watermark"
                            class="w-full py-2 bg-emerald-600 hover:bg-emerald-500 text-white text-xs font-bold rounded border border-emerald-500 transition flex items-center justify-center gap-2">
                            <i class="fas fa-magic"></i>
                            Auto Remove (G)
                        </button>
                        <div id="gemini-watermark-status"
                            class="px-2 py-1.5 bg-slate-800 rounded border border-slate-700 text-xs text-center hidden">
                        </div>
                    </div>

                    <!-- Watermark (Manual Diamond Mode) -->
                    <div class="space-y-2">
                        <h4 class="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider">Manual
                            Removal
                        </h4>
                        <div id="watermark-status"
                            class="px-2 py-1.5 bg-slate-100 dark:bg-slate-800 rounded border border-slate-200 dark:border-slate-700 text-xs text-center text-slate-600 dark:text-slate-300">
                            Click & drag to draw diamond
                        </div>
                        <div class="flex gap-2">
                            <button id="btn-clear-mask"
                                class="flex-1 py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-300 hover:text-slate-900 dark:hover:text-white text-xs rounded border border-slate-200 dark:border-slate-600 transition">
                                Clear (C)
                            </button>
                            <label
                                class="flex items-center gap-1.5 cursor-pointer text-xs text-slate-500 dark:text-slate-400">
                                <input type="checkbox" id="chk-persist-mask" checked
                                    class="w-3.5 h-3.5 rounded border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-blue-500">
                                Keep
                            </label>
                        </div>
                    </div>

                    <!-- Export -->
                    <div class="space-y-2">
                        <h4 class="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider">Output
                        </h4>
                        <div class="flex items-center justify-between">
                            <select id="sel-format"
                                class="bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-600 text-xs text-slate-700 dark:text-white rounded px-2 py-1 outline-none focus:border-blue-500">
                                <option value="image/png" selected>PNG</option>
                                <option value="image/jpeg">JPEG</option>
                            </select>
                            <div id="quality-wrapper" class="flex items-center gap-2">
                                <input type="range" id="rng-quality" min="10" max="100" value="95" step="5"
                                    class="w-16 h-1.5 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                                <span id="quality-val" class="text-xs text-blue-600 dark:text-blue-400 w-8">95%</span>
                            </div>
                        </div>
                    </div>

                    <!-- Actions -->
                    <div class="pt-3 border-t border-slate-200 dark:border-slate-700 space-y-2">
                        <button id="btn-save"
                            class="w-full py-2.5 bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-500 text-white text-sm font-bold rounded-lg shadow-lg shadow-blue-500/20 transition">
                            üíæ Save (S)
                        </button>
                        <button id="btn-batch-all"
                            class="w-full py-2 bg-purple-600 hover:bg-purple-500 text-white text-xs font-bold rounded border border-purple-500 transition flex items-center justify-center gap-2 hidden">
                            <i class="fas fa-play-circle"></i>
                            Batch Process All
                        </button>
                        <button id="btn-save-original"
                            class="w-full py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-300 text-xs rounded border border-slate-200 dark:border-slate-600 transition">
                            Save Original (O)
                        </button>
                        <button id="btn-download"
                            class="w-full py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 text-slate-700 dark:text-white text-xs rounded border border-slate-200 dark:border-slate-600 hidden transition">
                            ‚¨áÔ∏è Download to Local
                        </button>
                    </div>

                    <div class="text-[10px] text-slate-500 dark:text-slate-600 text-center space-y-1 pb-4">
                        <p>‚Üê / ‚Üí : Switch Image</p>
                        <p>S : Save | O : Save Original | C : Clear</p>
                    </div>

                </div>
            </aside>
        </div>
    </div>

    <!-- Hidden Inputs -->
    <input type="file" id="fallback-file" style="display: none;" accept="image/png, image/jpeg, image/webp">
    <input type="file" id="fallback-dir" style="display: none;" webkitdirectory directory multiple>

    <script>
        // === State Management ===
        const state = {
            inputHandle: null,
            outputHandle: null,
            files: [], // { name, handle }
            currentIndex: -1,
            currentImage: null, // Image Object
            currentFileName: '', // Current filename
            isSingleFileMode: false, // Single file mode
            mode: 'pad', // 'pad' or 'crop'
            outputFormat: 'image/png',
            outputQuality: 0.95,
            cropRect: { x: 0, y: 0, w: 0, h: 0 }, // Crop rect
            // Watermark single mask mode
            watermarkRect: null, // { x, y, w, h } - Normalized coordinates (0-1)
            isDrawingRect: false,
            rectStart: { x: 0, y: 0 },
        };

        // DOM Elements
        const els = {
            singleBtn: document.getElementById('btn-single'),
            inputBtn: document.getElementById('btn-input'),
            outputBtn: document.getElementById('btn-output'),
            downloadBtn: document.getElementById('btn-download'),
            fileList: document.getElementById('file-list'),
            fileCount: document.getElementById('file-count'),
            mainCanvas: document.getElementById('main-canvas'),
            layerCanvas: document.getElementById('interaction-layer'),
            ctxMain: document.getElementById('main-canvas').getContext('2d'),
            ctxLayer: document.getElementById('interaction-layer').getContext('2d'),
            radioModes: document.getElementsByName('crop-mode'),
            clearMaskBtn: document.getElementById('btn-clear-mask'),
            persistChk: document.getElementById('chk-persist-mask'),
            saveBtn: document.getElementById('btn-save'),
            saveOriginalBtn: document.getElementById('btn-save-original'),
            toast: document.getElementById('toast'),
            watermarkStatus: document.getElementById('watermark-status'),
            geminiWatermarkBtn: document.getElementById('btn-gemini-watermark'),
            geminiWatermarkStatus: document.getElementById('gemini-watermark-status'),
            fallbackFile: document.getElementById('fallback-file'),
            fallbackDir: document.getElementById('fallback-dir'),
            selFormat: document.getElementById('sel-format'),
            rngQuality: document.getElementById('rng-quality'),
            qualityVal: document.getElementById('quality-val'),
            qualityWrapper: document.getElementById('quality-wrapper'),
            outputInfo: document.getElementById('output-info'),
            batchAllBtn: document.getElementById('btn-batch-all')
        };

        // === 0. Output Settings ===
        // PNG is default, disable quality slider
        els.qualityWrapper.style.opacity = '0.5';
        els.qualityWrapper.style.pointerEvents = 'none';

        els.selFormat.onchange = (e) => {
            state.outputFormat = e.target.value;
            // PNG is lossless, no quality slider needed
            if (state.outputFormat === 'image/png') {
                els.qualityWrapper.style.opacity = '0.5';
                els.qualityWrapper.style.pointerEvents = 'none';
            } else {
                els.qualityWrapper.style.opacity = '1';
                els.qualityWrapper.style.pointerEvents = 'auto';
            }
        };

        els.rngQuality.oninput = (e) => {
            const val = parseInt(e.target.value);
            els.qualityVal.textContent = val + '%';
            state.outputQuality = val / 100;
        };

        // === 1. File System & Compatibility ===

        // Single file mode click
        els.singleBtn.onclick = async () => {
            if ('showOpenFilePicker' in window) {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'Image Files',
                            accept: { 'image/*': ['.jpg', '.jpeg', '.png', '.webp'] }
                        }],
                        multiple: false
                    });
                    await loadSingleFile(fileHandle);
                } catch (err) {
                    // SecurityError means we are in a context that blocks the API (e.g. iframe)
                    if (err.name === 'SecurityError' || err.name === 'NotAllowedError') {
                        els.fallbackFile.click();
                    } else if (err.name !== 'AbortError') {
                        console.error(err);
                    }
                }
            } else {
                // Fallback mode
                els.fallbackFile.click();
            }
        };

        // Directory mode click
        els.inputBtn.onclick = async () => {
            if ('showDirectoryPicker' in window) {
                try {
                    state.inputHandle = await window.showDirectoryPicker();
                    setupBatchModeUI();
                    await loadFileList();
                } catch (err) {
                    // SecurityError means we are in a context that blocks the API
                    if (err.name === 'SecurityError' || err.name === 'NotAllowedError') {
                        els.fallbackDir.click();
                    } else if (err.name !== 'AbortError') {
                        console.error(err);
                    }
                }
            } else {
                // Fallback mode
                els.fallbackDir.click();
            }
        };

        els.outputBtn.onclick = async () => {
            // Output directory requires API (Not supported in fallback mode)
            try {
                const handle = await window.showDirectoryPicker({ mode: 'readwrite' });
                state.outputHandle = handle;
                els.outputInfo.textContent = `Output folder: ${handle.name}`;
                els.outputInfo.style.color = '#4a90e2';
                showToast("Output folder set");
            } catch (err) {
                if (err.name === 'SecurityError' || err.name === 'NotAllowedError') {
                    // Permission denied or blocked by iframe policy
                    const msg = "‚ö†Ô∏è System Notification: Cannot select custom folder\n\n" +
                        "Reason: The current environment (e.g., VS Code preview) blocks this feature due to security policies.\n\n" +
                        "üëâ Solution: Open this .html file directly in Chrome or Edge to remove the restriction.\n\n" +
                        "(Current files will be automatically saved to your default 'Downloads' folder)";
                    alert(msg);

                    // Hide button to avoid further errors
                    els.outputBtn.style.display = 'none';
                    els.outputInfo.textContent = 'Save location: Browser Downloads (Env restricted)';
                    state.outputHandle = null; // Ensure cleared
                } else if (err.name !== 'AbortError') {
                    console.error(err);
                }
            }
        };

        // Listen for fallback input changes
        els.fallbackFile.onchange = (e) => {
            const file = e.target.files[0];
            if (file) loadSingleFile(file);
            e.target.value = ''; // Reset for re-selection
        };

        els.fallbackDir.onchange = (e) => {
            if (e.target.files && e.target.files.length > 0) {
                // Store FileList as array
                state.inputHandle = Array.from(e.target.files);
                setupBatchModeUI();
                loadFileList(); // Load list
            }
            e.target.value = '';
        };

        function setupBatchModeUI() {
            state.isSingleFileMode = false;

            // Check DirectoryPicker support to toggle output btn visibility
            const supportDirPicker = 'showDirectoryPicker' in window;

            if (supportDirPicker) {
                els.outputBtn.style.display = 'block';
                if (state.outputHandle) {
                    els.outputInfo.textContent = `Output: ${state.outputHandle.name}`;
                } else {
                    els.outputInfo.textContent = 'Default: Downloads (Click button above to change)';
                }
            } else {
                els.outputBtn.style.display = 'none';
                els.outputInfo.textContent = 'Save location: Browser Downloads (System restricted)';
            }

            els.downloadBtn.style.display = 'none';
            els.saveBtn.textContent = 'Save & Next (S)';
            els.batchAllBtn.classList.remove('hidden');
        }

        // Load single file (Supports Handle or File)
        async function loadSingleFile(fileOrHandle) {
            state.isSingleFileMode = true;
            state.files = [{
                name: fileOrHandle.name,
                handle: fileOrHandle // May be File object or FileSystemFileHandle
            }];
            state.currentIndex = 0;
            state.currentFileName = fileOrHandle.name;
            updateFilenameDisplay();

            // Update UI
            els.downloadBtn.style.display = 'block';
            els.saveBtn.textContent = 'Save (S)';
            els.outputInfo.textContent = 'Single File Mode: Save to Downloads';

            els.fileList.innerHTML = '';
            const li = document.createElement('li');
            li.textContent = fileOrHandle.name;
            li.classList.add('active');
            els.fileList.appendChild(li);
            els.fileCount.textContent = 'Single File Mode';

            // Read
            await loadFileContent(fileOrHandle);

            // Reset selection
            if (!els.persistChk.checked) {
                resetWatermark();
            }
            updateWatermarkStatus();
            initCropRect();
            render();
        }

        // Unified file content loading
        async function loadFileContent(fileOrHandle) {
            let file;
            if (fileOrHandle.getFile) {
                // API Handle
                file = await fileOrHandle.getFile();
            } else {
                // Standard File object
                file = fileOrHandle;
            }
            const bmp = await createImageBitmap(file);
            state.currentImage = bmp;
        }


        function resetWatermark() {
            state.watermarkRect = null;
        }

        async function loadFileList() {
            state.files = [];
            els.fileList.innerHTML = '';

            const isApiMode = state.inputHandle && !Array.isArray(state.inputHandle);

            if (isApiMode) {
                // API Mode: Iterate DirectoryHandle
                for await (const entry of state.inputHandle.values()) {
                    if (entry.kind === 'file' && /\.(jpg|jpeg|png|webp)$/i.test(entry.name)) {
                        state.files.push({ name: entry.name, handle: entry });
                    }
                }
            } else {
                // Fallback Mode: state.inputHandle is File array
                state.files = state.inputHandle
                    .filter(f => /\.(jpg|jpeg|png|webp)$/i.test(f.name))
                    .map(f => ({ name: f.name, handle: f }));
            }

            // Sort
            state.files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

            // Render list
            state.files.forEach((f, i) => {
                const li = document.createElement('li');
                li.textContent = f.name;
                li.className = 'p-2 text-xs rounded cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-700 truncate text-slate-600 dark:text-slate-300 transition-colors';
                li.onclick = () => loadFile(i);
                els.fileList.appendChild(li);
            });

            els.fileCount.textContent = `${state.files.length} images`;
            if (state.files.length > 0) loadFile(0);
        }

        async function loadFile(index) {
            if (index < 0 || index >= state.files.length) return;

            // UI Update
            const items = els.fileList.children;
            if (state.currentIndex >= 0 && items[state.currentIndex]) {
                const prev = items[state.currentIndex];
                prev.classList.remove('bg-blue-600', 'text-white');
                prev.classList.add('text-slate-600', 'dark:text-slate-300');
            }
            state.currentIndex = index;
            const current = items[index];
            current.classList.remove('text-slate-600', 'dark:text-slate-300');
            current.classList.add('bg-blue-600', 'text-white');
            current.scrollIntoView({ block: 'nearest' });

            state.currentFileName = state.files[index].name;
            updateFilenameDisplay();

            // Read file
            await loadFileContent(state.files[index].handle);

            // Mask handling
            if (!els.persistChk.checked) {
                resetWatermark();
            }
            updateWatermarkStatus();

            // Initialize crop rect
            initCropRect();

            render();
        }

        function initCropRect() {
            if (!state.currentImage) return;
            const imgW = state.currentImage.width;
            const imgH = state.currentImage.height;

            // Target 16:9
            // If crop mode, init max 16:9 rect
            let targetW = imgW;
            let targetH = targetW * (9 / 16);
            if (targetH > imgH) {
                targetH = imgH;
                targetW = targetH * (16 / 9);
            }

            state.cropRect = {
                x: (imgW - targetW) / 2,
                y: (imgH - targetH) / 2,
                w: targetW,
                h: targetH
            };
        }

        // === 2. Render Logic ===

        // Listen for mode change
        els.radioModes.forEach(r => r.addEventListener('change', (e) => {
            state.mode = e.target.value;
            render();
        }));

        function render() {
            if (!state.currentImage) return;

            // 1. Set canvas dimensions
            // Logic: MainCanvas is always "Final Preview"
            // Pad Mode: MainCanvas is expanded 16:9
            // Crop Mode: MainCanvas shows original, InteractionLayer shows crop rect
            // To simplify, we rely on MainCanvas showing the original base image,
            // and we do the actual crop/pad only when saving.
            // This ensures inpainting coordinates match the original image.

            const img = state.currentImage;
            els.mainCanvas.width = img.width;
            els.mainCanvas.height = img.height;
            els.layerCanvas.width = img.width;
            els.layerCanvas.height = img.height;

            // Draw original image
            els.ctxMain.drawImage(img, 0, 0);

            // 2. Apply inpainting (Simple surrounding fill algorithm)
            applyInpainting();

            // 3. Draw interaction layer (Crop rect)
            drawOverlay();
        }

        function applyInpainting() {
            // Diamond gradient fill: Sample from diamond edges, use bilinear interpolation to fill
            if (!state.watermarkRect) return;

            const ctx = els.ctxMain;
            const imgW = els.mainCanvas.width;
            const imgH = els.mainCanvas.height;

            // Restore watermark rect coords (Normalized -> Pixel)
            const rect = {
                x: Math.floor(state.watermarkRect.x * imgW),
                y: Math.floor(state.watermarkRect.y * imgH),
                w: Math.floor(state.watermarkRect.w * imgW),
                h: Math.floor(state.watermarkRect.h * imgH)
            };

            // Boundary check
            if (rect.w <= 0 || rect.h <= 0) return;
            if (rect.x < 0 || rect.y < 0 || rect.x + rect.w > imgW || rect.y + rect.h > imgH) return;

            // Diamond center and radius
            const cx = rect.x + rect.w / 2;
            const cy = rect.y + rect.h / 2;
            const rx = rect.w / 2; // Horizontal radius
            const ry = rect.h / 2; // Vertical radius

            // Sampling margin (Expand outward)
            const margin = 5;

            // Check if point inside diamond
            function isInsideDiamond(px, py) {
                const dx = Math.abs(px - cx) / rx;
                const dy = Math.abs(py - cy) / ry;
                return (dx + dy) <= 1.0;
            }

            // Sample color from outside diamond vertices
            function sampleDiamondVertexColor(vertex, offsetX, offsetY) {
                const sx = Math.max(0, Math.min(imgW - 1, Math.floor(vertex.x + offsetX)));
                const sy = Math.max(0, Math.min(imgH - 1, Math.floor(vertex.y + offsetY)));
                const pixel = ctx.getImageData(sx, sy, 1, 1).data;
                return { r: pixel[0], g: pixel[1], b: pixel[2] };
            }

            // Diamond vertices
            const topVertex = { x: cx, y: rect.y };
            const bottomVertex = { x: cx, y: rect.y + rect.h };
            const leftVertex = { x: rect.x, y: cy };
            const rightVertex = { x: rect.x + rect.w, y: cy };

            // Sample colors from vertices
            const topColor = sampleDiamondVertexColor(topVertex, 0, -margin);
            const bottomColor = sampleDiamondVertexColor(bottomVertex, 0, margin);
            const leftColor = sampleDiamondVertexColor(leftVertex, -margin, 0);
            const rightColor = sampleDiamondVertexColor(rightVertex, margin, 0);

            // Use ImageData for efficient pixel manipulation
            const imageData = ctx.getImageData(rect.x, rect.y, rect.w, rect.h);
            const data = imageData.data;

            // Gradient fill diamond area
            for (let py = 0; py < rect.h; py++) {
                for (let px = 0; px < rect.w; px++) {
                    const absX = rect.x + px;
                    const absY = rect.y + py;

                    // Fill only pixels inside diamond
                    if (!isInsideDiamond(absX, absY)) continue;

                    // Calculate normalized position relative to center
                    const tx = rx > 0 ? (px - rx) / rx : 0; // -1 to 1
                    const ty = ry > 0 ? (py - ry) / ry : 0; // -1 to 1

                    // Calculate weights based on position
                    // Top/Bottom weights
                    const topWeight = Math.max(0, -ty);
                    const bottomWeight = Math.max(0, ty);
                    // Left/Right weights
                    const leftWeight = Math.max(0, -tx);
                    const rightWeight = Math.max(0, tx);

                    // Normalize weights
                    let totalWeight = topWeight + bottomWeight + leftWeight + rightWeight;
                    if (totalWeight === 0) totalWeight = 1;

                    // Weighted color blending
                    const finalR = (topColor.r * topWeight + bottomColor.r * bottomWeight +
                        leftColor.r * leftWeight + rightColor.r * rightWeight) / totalWeight;
                    const finalG = (topColor.g * topWeight + bottomColor.g * bottomWeight +
                        leftColor.g * leftWeight + rightColor.g * rightWeight) / totalWeight;
                    const finalB = (topColor.b * topWeight + bottomColor.b * bottomWeight +
                        leftColor.b * leftWeight + rightColor.b * rightWeight) / totalWeight;

                    // Add subtle noise for natural texture
                    const noise = (Math.random() - 0.5) * 4;

                    const idx = (py * rect.w + px) * 4;
                    data[idx] = Math.max(0, Math.min(255, Math.round(finalR + noise)));
                    data[idx + 1] = Math.max(0, Math.min(255, Math.round(finalG + noise)));
                    data[idx + 2] = Math.max(0, Math.min(255, Math.round(finalB + noise)));
                }
            }

            ctx.putImageData(imageData, rect.x, rect.y);
        }

        // === Gemini Watermark Removal (Reverse Alpha Blending) ===

        // Pre-captured watermark alpha maps (inline base64)
        const geminiWatermark = {
            alphaMaps: {},
            bg48: null,
            bg96: null,
            initialized: false,
            // Base64 encoded watermark capture images
            BG_48_BASE64: 'data:image/png;base64,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',
            BG_96_BASE64: 'data:image/png;base64,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'
        };

        // Load watermark assets from base64
        async function initGeminiWatermark() {
            if (geminiWatermark.initialized) return true;

            try {
                const [bg48, bg96] = await Promise.all([
                    loadImageAsync(geminiWatermark.BG_48_BASE64),
                    loadImageAsync(geminiWatermark.BG_96_BASE64)
                ]);
                geminiWatermark.bg48 = bg48;
                geminiWatermark.bg96 = bg96;
                geminiWatermark.initialized = true;
                return true;
            } catch (err) {
                console.error('Failed to load Gemini watermark assets:', err);
                return false;
            }
        }

        function loadImageAsync(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        // Calculate alpha map from pre-captured watermark background
        function calculateAlphaMap(bgImage, size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bgImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, size, size);
            const { data } = imageData;

            const alphaMap = new Float32Array(size * size);
            for (let i = 0; i < alphaMap.length; i++) {
                const idx = i * 4;
                const maxChannel = Math.max(data[idx], data[idx + 1], data[idx + 2]);
                alphaMap[i] = maxChannel / 255.0;
            }
            return alphaMap;
        }

        // Detect watermark config based on image dimensions
        function detectWatermarkConfig(imageWidth, imageHeight) {
            if (imageWidth > 1024 && imageHeight > 1024) {
                return { logoSize: 96, marginRight: 64, marginBottom: 64 };
            } else {
                return { logoSize: 48, marginRight: 32, marginBottom: 32 };
            }
        }

        // Calculate watermark position
        function calculateWatermarkPosition(imageWidth, imageHeight, config) {
            const { logoSize, marginRight, marginBottom } = config;
            return {
                x: imageWidth - marginRight - logoSize,
                y: imageHeight - marginBottom - logoSize,
                width: logoSize,
                height: logoSize
            };
        }

        // Remove watermark using reverse alpha blending
        function removeGeminiWatermarkFromImageData(imageData, alphaMap, position) {
            const { x, y, width, height } = position;
            const ALPHA_THRESHOLD = 0.002;
            const MAX_ALPHA = 0.99;
            const LOGO_VALUE = 255;

            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const imgIdx = ((y + row) * imageData.width + (x + col)) * 4;
                    const alphaIdx = row * width + col;
                    let alpha = alphaMap[alphaIdx];

                    if (alpha < ALPHA_THRESHOLD) continue;

                    alpha = Math.min(alpha, MAX_ALPHA);
                    const oneMinusAlpha = 1.0 - alpha;

                    for (let c = 0; c < 3; c++) {
                        const watermarked = imageData.data[imgIdx + c];
                        const original = (watermarked - alpha * LOGO_VALUE) / oneMinusAlpha;
                        imageData.data[imgIdx + c] = Math.max(0, Math.min(255, Math.round(original)));
                    }
                }
            }
        }

        // Get or calculate alpha map for given size
        function getAlphaMap(size) {
            if (geminiWatermark.alphaMaps[size]) {
                return geminiWatermark.alphaMaps[size];
            }
            const bgImage = size === 48 ? geminiWatermark.bg48 : geminiWatermark.bg96;
            const alphaMap = calculateAlphaMap(bgImage, size);
            geminiWatermark.alphaMaps[size] = alphaMap;
            return alphaMap;
        }

        // Main function: Apply Gemini watermark removal
        async function applyGeminiWatermarkRemoval() {
            if (!state.currentImage) {
                showToast('Please load an image first');
                return;
            }

            // Show status
            els.geminiWatermarkStatus.classList.remove('hidden');
            els.geminiWatermarkStatus.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i> Initializing...';

            // Initialize if needed
            if (!await initGeminiWatermark()) {
                els.geminiWatermarkStatus.innerHTML = '<span class="text-red-400">‚ùå Failed to load watermark resources</span>';
                return;
            }

            els.geminiWatermarkStatus.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i> Processing...';

            // Get image dimensions from canvas
            const imgW = els.mainCanvas.width;
            const imgH = els.mainCanvas.height;

            // Detect watermark configuration
            const config = detectWatermarkConfig(imgW, imgH);
            const position = calculateWatermarkPosition(imgW, imgH, config);

            // Get alpha map
            const alphaMap = getAlphaMap(config.logoSize);

            // Get image data and apply removal
            const ctx = els.ctxMain;
            const imageData = ctx.getImageData(0, 0, imgW, imgH);
            removeGeminiWatermarkFromImageData(imageData, alphaMap, position);
            ctx.putImageData(imageData, 0, 0);

            // Update status
            els.geminiWatermarkStatus.innerHTML = `<span class="text-emerald-400">‚úì Watermark removed</span> <span class="text-slate-500">(${config.logoSize}√ó${config.logoSize})</span>`;
            showToast(`Gemini Watermark removed (${config.logoSize}√ó${config.logoSize})`);
        }

        // Button event handler
        els.geminiWatermarkBtn.onclick = applyGeminiWatermarkRemoval;

        function drawOverlay() {
            const ctx = els.ctxLayer;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Draw mask in crop mode
            if (state.mode === 'crop') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // Hollow out selected area
                const { x, y, w, h } = state.cropRect;
                ctx.clearRect(x, y, w, h);

                // Draw border
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                // Draw rule of thirds (Composition aid)
                ctx.beginPath();
                ctx.moveTo(x + w / 3, y); ctx.lineTo(x + w / 3, y + h);
                ctx.moveTo(x + 2 * w / 3, y); ctx.lineTo(x + 2 * w / 3, y + h);
                ctx.moveTo(x, y + h / 3); ctx.lineTo(x + w, y + h / 3);
                ctx.moveTo(x, y + 2 * h / 3); ctx.lineTo(x + w, y + 2 * h / 3);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.stroke();
            } else {
                // In Pad mode...
                // Pad mode doesn't strictly need overlay...
                // For simplicity...
            }

            // Draw brush cursor...
            // (Handled by mousemove)
        }


        // === 3. Interaction Logic ===

        // Update watermark status indicator
        function updateWatermarkStatus() {
            if (!els.watermarkStatus) return;
            if (state.watermarkRect) {
                els.watermarkStatus.innerHTML = 'Status: <span class="text-emerald-400 font-bold">‚úì Diamond Mask Ready</span>';
            } else {
                els.watermarkStatus.innerHTML = 'Status: <span class="text-blue-400 font-bold">Draw Diamond</span> (Select Watermark)';
            }
        }

        // Clear selection
        els.clearMaskBtn.onclick = () => {
            state.watermarkRect = null;
            updateWatermarkStatus();
            render();
        };

        // Mouse events
        let isDraggingCrop = false;
        let lastMouse = { x: 0, y: 0 };
        let tempRect = null; // Temp selection rect

        els.layerCanvas.addEventListener('mousedown', (e) => {
            const rect = els.layerCanvas.getBoundingClientRect();
            const scaleX = els.layerCanvas.width / rect.width;
            const scaleY = els.layerCanvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            if (state.mode === 'crop') {
                // Crop mode: Drag selection
                if (mx >= state.cropRect.x && mx <= state.cropRect.x + state.cropRect.w &&
                    my >= state.cropRect.y && my <= state.cropRect.y + state.cropRect.h) {
                    isDraggingCrop = true;
                    lastMouse = { x: mx, y: my };
                }
            } else {
                // Pad mode: Single mask watermark
                state.isDrawingRect = true;
                state.rectStart = { x: mx, y: my };
                tempRect = { x: mx, y: my, w: 0, h: 0 };
            }
        });

        els.layerCanvas.addEventListener('mousemove', (e) => {
            const rect = els.layerCanvas.getBoundingClientRect();
            const scaleX = els.layerCanvas.width / rect.width;
            const scaleY = els.layerCanvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            // Redraw interaction layer
            drawOverlay();
            const ctx = els.ctxLayer;

            if (state.mode === 'crop' && isDraggingCrop) {
                const dx = mx - lastMouse.x;
                const dy = my - lastMouse.y;
                state.cropRect.x += dx;
                state.cropRect.y += dy;

                // Limit boundaries
                const cw = els.layerCanvas.width;
                const ch = els.layerCanvas.height;
                if (state.cropRect.x < 0) state.cropRect.x = 0;
                if (state.cropRect.y < 0) state.cropRect.y = 0;
                if (state.cropRect.x + state.cropRect.w > cw) state.cropRect.x = cw - state.cropRect.w;
                if (state.cropRect.y + state.cropRect.h > ch) state.cropRect.y = ch - state.cropRect.h;
                lastMouse = { x: mx, y: my };
                drawOverlay();
            } else if (state.isDrawingRect && state.mode === 'pad') {
                // Draw temporary rect preview
                tempRect = {
                    x: Math.min(state.rectStart.x, mx),
                    y: Math.min(state.rectStart.y, my),
                    w: Math.abs(mx - state.rectStart.x),
                    h: Math.abs(my - state.rectStart.y)
                };

                // Draw temporary diamond rect
                ctx.strokeStyle = '#10b981'; // emerald color
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                drawDiamond(ctx, tempRect.x, tempRect.y, tempRect.w, tempRect.h);
                ctx.setLineDash([]);
            }

            // Draw existing selection
            drawWatermarkRects(ctx);
        });

        window.addEventListener('mouseup', (e) => {
            if (state.isDrawingRect && tempRect && tempRect.w > 5 && tempRect.h > 5) {
                const img = state.currentImage;
                if (img) {
                    // Normalize storage - Single mask mode
                    state.watermarkRect = {
                        x: tempRect.x / img.width,
                        y: tempRect.y / img.height,
                        w: tempRect.w / img.width,
                        h: tempRect.h / img.height
                    };
                    updateWatermarkStatus();
                }
            }

            state.isDrawingRect = false;
            isDraggingCrop = false;
            tempRect = null;
            if (state.currentImage) render();
        });

        // Helper to clean diamond
        function drawDiamond(ctx, x, y, w, h) {
            const cx = x + w / 2;
            const cy = y + h / 2;
            ctx.beginPath();
            ctx.moveTo(cx, y);           // Top vertex
            ctx.lineTo(x + w, cy);       // Right vertex
            ctx.lineTo(cx, y + h);       // Bottom vertex
            ctx.lineTo(x, cy);           // Left vertex
            ctx.closePath();
            ctx.stroke();
        }

        // Draw existing diamond mask
        function drawWatermarkRects(ctx) {
            const img = state.currentImage;
            if (!img || !state.watermarkRect) return;

            // Draw watermark diamond (green)
            const rect = {
                x: state.watermarkRect.x * img.width,
                y: state.watermarkRect.y * img.height,
                w: state.watermarkRect.w * img.width,
                h: state.watermarkRect.h * img.height
            };
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            drawDiamond(ctx, rect.x, rect.y, rect.w, rect.h);

            // Label - above diamond center
            ctx.fillStyle = '#10b981';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Watermark Area', rect.x + rect.w / 2, rect.y + rect.h / 2 - 5);
            ctx.textAlign = 'left'; // Reset
        }


        // === 4. Save Logic ===

        els.saveBtn.onclick = processAndSave;
        els.downloadBtn.onclick = downloadToLocal;

        // Generate processed image (Shared logic)
        function generateProcessedImage() {
            if (!state.currentImage) return null;

            const img = state.currentImage;
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');

            let finalW, finalH;

            if (state.mode === 'pad') {
                const ratio = 16 / 9;
                if (img.width / img.height < ratio) {
                    finalH = img.height;
                    finalW = finalH * ratio;
                } else {
                    finalW = img.width;
                    finalH = finalW / ratio;
                }

                offCanvas.width = finalW;
                offCanvas.height = finalH;

                const pixel = els.ctxMain.getImageData(0, 0, 1, 1).data;
                offCtx.fillStyle = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
                offCtx.fillRect(0, 0, finalW, finalH);

                const dx = (finalW - img.width) / 2;
                const dy = (finalH - img.height) / 2;
                offCtx.drawImage(els.mainCanvas, dx, dy);
            } else {
                offCanvas.width = state.cropRect.w;
                offCanvas.height = state.cropRect.h;
                offCtx.drawImage(els.mainCanvas,
                    state.cropRect.x, state.cropRect.y, state.cropRect.w, state.cropRect.h,
                    0, 0, state.cropRect.w, state.cropRect.h
                );
            }

            return offCanvas;
        }

        // Download to local (Single file mode)
        async function downloadToLocal() {
            const offCanvas = generateProcessedImage();
            if (!offCanvas) return;

            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, state.outputFormat, state.outputQuality));

                // Update extension based on format
                const ext = state.outputFormat === 'image/png' ? '.png' : '.jpg';
                const filename = state.currentFileName.replace(/\.[^.]+$/, `_processed${ext}`);

                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast(`Downloaded: ${filename}`);
            } catch (err) {
                console.error(err);
                alert("Download Failed");
            }
        }

        // Check for duplicates in output dir
        async function scanOutputDirectory() {
            if (!state.outputHandle) return new Set();

            const existingFiles = new Set();
            try {
                for await (const entry of state.outputHandle.values()) {
                    if (entry.kind === 'file') {
                        // Store basename...
                        const baseName = entry.name.replace(/\.[^.]+$/, '');
                        existingFiles.add(baseName);
                    }
                }
            } catch (err) {
                console.error('Failed to scan output directory:', err);
            }
            return existingFiles;
        }

        // Update file list display...
        async function updateFileListWithDuplicates() {
            const existingFiles = await scanOutputDirectory();
            state.processedFiles = existingFiles;

            const items = els.fileList.children;
            for (let i = 0; i < state.files.length; i++) {
                const baseName = state.files[i].name.replace(/\.[^.]+$/, '');
                const li = items[i];
                if (li && existingFiles.has(baseName)) {
                    // Mark as processed
                    if (!li.querySelector('.duplicate-mark')) {
                        const mark = document.createElement('span');
                        mark.className = 'duplicate-mark text-emerald-400 ml-1';
                        mark.textContent = '‚úì';
                        mark.title = 'Already in output folder';
                        li.appendChild(mark);
                    }
                }
            }

            return existingFiles;
        }

        // Save to output dir (Batch mode)
        async function processAndSave() {
            // Single file mode downloads directly
            if (state.isSingleFileMode) {
                await downloadToLocal();
                return;
            }

            if (!state.currentImage) return;

            // Use download mode if no output handle
            if (!state.outputHandle) {
                await downloadToLocal();
                // Auto switch to next in batch mode
                if (!state.isSingleFileMode) {
                    if (state.currentIndex < state.files.length - 1) {
                        loadFile(state.currentIndex + 1);
                    } else {
                        showToast("All images processed!");
                    }
                }
                return;
            }

            // No need to block outputHandle...

            const offCanvas = generateProcessedImage();
            if (!offCanvas) return;

            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, state.outputFormat, state.outputQuality));

                // Update extension based on format
                const ext = state.outputFormat === 'image/png' ? '.png' : '.jpg';
                // Batch save keeps filename...
                let filename = state.files[state.currentIndex].name;
                if (!filename.endsWith(ext)) {
                    filename = filename.replace(/\.[^.]+$/, ext);
                }

                const newFileHandle = await state.outputHandle.getFileHandle(filename, { create: true });
                const writable = await newFileHandle.createWritable();
                await writable.write(blob);
                await writable.close();

                showToast(`Saved: ${filename}`);

                if (state.currentIndex < state.files.length - 1) {
                    loadFile(state.currentIndex + 1);
                } else {
                    showToast("All images processed!");
                }
            } catch (err) {
                console.error(err);
                alert("Save failed, please check directory permissions");
            }
        }

        async function verifyPermission(fileHandle, readWrite) {
            const options = {};
            if (readWrite) {
                options.mode = 'readwrite';
            }
            // Check if permission was already granted. If so, return true.
            if ((await fileHandle.queryPermission(options)) === 'granted') {
                return true;
            }
            // Request permission. If the user grants permission, return true.
            if ((await fileHandle.requestPermission(options)) === 'granted') {
                return true;
            }
            // The user didn't grant permission, so return false.
            return false;
        }

        // === Batch Process All ===
        els.batchAllBtn.onclick = batchProcessAll;

        async function batchProcessAll() {
            if (state.files.length === 0) {
                alert("No images to process");
                return;
            }
            if (!state.outputHandle) {
                alert("Please select output folder first");
                return;
            }

            const confirmProcess = await showConfirm({
                title: "Confirm Batch Processing",
                message: `Start batch processing ${state.files.length} images?\n\n- Remove Gemini Watermark\n- Save as PNG (100% Quality)\n- Output to: ${state.outputHandle.name}`,
                confirmText: "Start Processing",
                cancelText: "Cancel"
            });
            if (!confirmProcess) return;

            // Verify permission before starting
            const hasPermission = await verifyPermission(state.outputHandle, true);
            if (!hasPermission) {
                alert("Write permission is required to save processed images.");
                return;
            }

            // Disable button
            els.batchAllBtn.disabled = true;
            els.batchAllBtn.classList.add('opacity-50', 'cursor-not-allowed');

            // Force PNG 100%
            state.outputFormat = 'image/png';
            els.selFormat.value = 'image/png';
            els.qualityWrapper.style.opacity = '0.5';
            els.qualityWrapper.style.pointerEvents = 'none';

            // Initialize watermark removal if needed
            showToast("Initializing assets...");
            await initGeminiWatermark();

            for (let i = 0; i < state.files.length; i++) {
                try {
                    // Update UI to show current progress
                    state.currentIndex = i;
                    updateFilenameDisplay();
                    els.geminiWatermarkStatus.classList.remove('hidden');
                    els.geminiWatermarkStatus.innerHTML = `<i class="fas fa-spinner fa-spin mr-1"></i> [${i + 1}/${state.files.length}] Processing...`;

                    // 1. Load file
                    await loadFileContent(state.files[i].handle);
                    // Update canvas dimensions
                    const img = state.currentImage;
                    els.mainCanvas.width = img.width;
                    els.mainCanvas.height = img.height;
                    els.ctxMain.drawImage(img, 0, 0);

                    // Re-initialize crop rect for current image size
                    initCropRect();

                    // 2. Remove Gemini Watermark
                    const config = detectWatermarkConfig(img.width, img.height);
                    const position = calculateWatermarkPosition(img.width, img.height, config);
                    const alphaMap = getAlphaMap(config.logoSize);
                    const imageData = els.ctxMain.getImageData(0, 0, img.width, img.height);
                    removeGeminiWatermarkFromImageData(imageData, alphaMap, position);
                    els.ctxMain.putImageData(imageData, 0, 0);

                    // (Optional) Apply inpainting if manual diamond is set (Persist check)
                    if (state.watermarkRect && els.persistChk.checked) {
                        applyInpainting();
                    }

                    // 3. Generate Processed Image (Apply Pad/Crop)
                    const offCanvas = generateProcessedImage();
                    const blob = await new Promise(r => offCanvas.toBlob(r, 'image/png', 1.0));

                    // 4. Save
                    let filename = state.files[i].name;
                    if (!filename.toLowerCase().endsWith('.png')) {
                        filename = filename.replace(/\.[^.]+$/, '.png');
                    }

                    const newFileHandle = await state.outputHandle.getFileHandle(filename, { create: true });
                    const writable = await newFileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();

                } catch (err) {
                    console.error(`Error processing ${state.files[i].name}:`, err);
                }
            }

            // Re-enable button
            els.batchAllBtn.disabled = false;
            els.batchAllBtn.classList.remove('opacity-50', 'cursor-not-allowed');

            els.geminiWatermarkStatus.innerHTML = `<span class="text-emerald-400">‚úì Batch processing complete!</span>`;
            showToast(`Successfully processed ${state.files.length} images`);

            // Reload the first image to refresh UI
            loadFile(0);
        }

        // === Helpers ===

        function showToast(msg) {
            // Update to use flex/hidden instead of display block
            els.toast.innerHTML = `<i class="fas fa-info-circle text-blue-400"></i> <span>${msg}</span>`;
            els.toast.classList.remove('hidden');
            // Assuming default display is flex due to class="... flex ..." in HTML
            setTimeout(() => els.toast.classList.add('hidden'), 2000);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') loadFile(state.currentIndex + 1);
            if (e.key === 'ArrowLeft') loadFile(state.currentIndex - 1);
            if (e.key.toLowerCase() === 's') processAndSave();
            if (e.key.toLowerCase() === 'o') saveOriginal();
            if (e.key.toLowerCase() === 'g') applyGeminiWatermarkRemoval();
            if (e.key.toLowerCase() === 'c') {
                // Shortcut to clear selection
                state.watermarkRect = null;
                updateWatermarkStatus();
                render();
            }
        });

        // Save original (Skip processing)
        els.saveOriginalBtn.onclick = saveOriginal;

        async function saveOriginal() {
            if (!state.currentImage) return;

            // Create temp canvas...
            const img = state.currentImage;
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');

            let finalW, finalH;
            if (state.mode === 'pad') {
                const ratio = 16 / 9;
                if (img.width / img.height < ratio) {
                    finalH = img.height;
                    finalW = finalH * ratio;
                } else {
                    finalW = img.width;
                    finalH = finalW / ratio;
                }
                offCanvas.width = finalW;
                offCanvas.height = finalH;

                // Sample background color from top-left
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                const pixel = tempCtx.getImageData(0, 0, 1, 1).data;
                offCtx.fillStyle = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
                offCtx.fillRect(0, 0, finalW, finalH);

                const dx = (finalW - img.width) / 2;
                const dy = (finalH - img.height) / 2;
                offCtx.drawImage(img, dx, dy);
            } else {
                offCanvas.width = state.cropRect.w;
                offCanvas.height = state.cropRect.h;

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                offCtx.drawImage(tempCanvas,
                    state.cropRect.x, state.cropRect.y, state.cropRect.w, state.cropRect.h,
                    0, 0, state.cropRect.w, state.cropRect.h
                );
            }

            // Save
            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, state.outputFormat, state.outputQuality));
                const ext = state.outputFormat === 'image/png' ? '.png' : '.jpg';
                let filename = state.currentFileName.replace(/\.[^.]+$/, ext);

                if (state.outputHandle) {
                    const newFileHandle = await state.outputHandle.getFileHandle(filename, { create: true });
                    const writable = await newFileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    showToast(`Saved Original: ${filename}`);
                } else {
                    // Download mode
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast(`Downloaded Original: ${filename}`);
                }

                // Switch to next image
                if (!state.isSingleFileMode && state.currentIndex < state.files.length - 1) {
                    loadFile(state.currentIndex + 1);
                } else if (!state.isSingleFileMode) {
                    showToast("All images processed!");
                }
            } catch (err) {
                console.error(err);
                alert("Save Failed");
            }
        }

        // Update filename display
        function updateFilenameDisplay() {
            const el = document.getElementById('current-filename');
            if (el && state.currentFileName) {
                el.textContent = state.currentFileName;
            } else if (el) {
                el.textContent = 'No file selected';
            }
        }

    </script>

    <!-- Custom Confirmation Modal -->
    <div id="custom-confirm" class="fixed inset-0 z-[100] hidden items-center justify-center p-4">
        <div class="absolute inset-0 bg-slate-900/60 backdrop-blur-sm transition-opacity" id="confirm-overlay"></div>
        <div class="relative bg-white dark:bg-slate-850 rounded-2xl shadow-2xl border border-slate-200 dark:border-slate-700 w-full max-w-sm overflow-hidden transform transition-all scale-95 opacity-0"
            id="confirm-box">
            <div class="p-6">
                <div class="flex items-center gap-4 mb-4">
                    <div
                        class="w-12 h-12 rounded-full bg-blue-100 dark:bg-blue-900/30 flex items-center justify-center shrink-0">
                        <i class="fas fa-question-circle text-blue-600 dark:text-blue-400 text-xl"></i>
                    </div>
                    <h3 class="text-lg font-bold text-slate-900 dark:text-white" id="confirm-title">Confirm Action</h3>
                </div>
                <div class="text-sm text-slate-600 dark:text-slate-400 mb-6 leading-relaxed whitespace-pre-wrap"
                    id="confirm-message">
                    Are you sure you want to proceed?
                </div>
                <div class="flex gap-3">
                    <button id="confirm-cancel"
                        class="flex-1 px-4 py-2.5 rounded-xl border border-slate-200 dark:border-slate-700 text-sm font-medium text-slate-600 dark:text-slate-400 hover:bg-slate-50 dark:hover:bg-slate-800 transition-colors">
                        Cancel
                    </button>
                    <button id="confirm-ok"
                        class="flex-1 px-4 py-2.5 rounded-xl bg-blue-600 hover:bg-blue-500 text-sm font-bold text-white shadow-lg shadow-blue-500/20 transition-colors">
                        Process
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Custom Confirmation Logic
        async function showConfirm({ title, message, confirmText = 'Confirm', cancelText = 'Cancel' }) {
            const modal = document.getElementById('custom-confirm');
            const box = document.getElementById('confirm-box');
            const titleEl = document.getElementById('confirm-title');
            const msgEl = document.getElementById('confirm-message');
            const okBtn = document.getElementById('confirm-ok');
            const cancelBtn = document.getElementById('confirm-cancel');

            titleEl.textContent = title;
            msgEl.textContent = message;
            okBtn.textContent = confirmText;
            cancelBtn.textContent = cancelText;

            modal.classList.remove('hidden');
            modal.classList.add('flex');

            // Trigger animation
            requestAnimationFrame(() => {
                box.classList.remove('scale-95', 'opacity-0');
                box.classList.add('scale-100', 'opacity-100');
            });

            return new Promise((resolve) => {
                const close = (result) => {
                    box.classList.remove('scale-100', 'opacity-100');
                    box.classList.add('scale-95', 'opacity-0');
                    setTimeout(() => {
                        modal.classList.add('hidden');
                        modal.classList.remove('flex');
                        resolve(result);
                    }, 200);
                };

                okBtn.onclick = () => close(true);
                cancelBtn.onclick = () => close(false);
                document.getElementById('confirm-overlay').onclick = () => close(false);
            });
        }
    </script>
</body>

</html>