<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>16:9 å›¾ç‰‡å¤„ç†ä¸å»æ°´å°å·¥å…·</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #2d2d2d;
            --accent-color: #4a90e2;
            --text-color: #e0e0e0;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* å¸ƒå±€ */
        #sidebar {
            width: 250px;
            background: var(--panel-color);
            display: flex;
            flex-direction: column;
            border-right: 1px solid #444;
        }

        #main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            align-items: center;
            justify-content: center;
            background: #111;
        }

        #toolbar {
            width: 280px;
            background: var(--panel-color);
            padding: 15px;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        /* æ–‡ä»¶åˆ—è¡¨ */
        #file-list {
            flex: 1;
            overflow-y: auto;
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #file-list li {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #3d3d3d;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #file-list li:hover {
            background: #3d3d3d;
        }

        #file-list li.active {
            background: var(--accent-color);
            color: white;
        }

        /* Canvas å®¹å™¨ */
        #canvas-wrapper {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 80vh;
        }

        /* äº¤äº’å±‚ (ç”¨äºç»˜åˆ¶é€‰æ¡†å’Œç¬”åˆ·) */
        #interaction-layer {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            touch-action: none;
        }

        /* æŒ‰é’®ä¸æ§ä»¶ */
        button {
            background: #444;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: 0.2s;
            font-size: 13px;
        }

        button:hover {
            background: #555;
        }

        button.primary {
            background: var(--accent-color);
        }

        button.primary:hover {
            background: #357abd;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-group {
            background: #363636;
            padding: 10px;
            border-radius: 6px;
        }

        .control-group h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            opacity: 0.8;
        }

        label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            margin-bottom: 5px;
            cursor: pointer;
        }

        input[type="range"] {
            flex: 1;
        }

        .status-bar {
            padding: 10px;
            font-size: 12px;
            color: #888;
            text-align: center;
            border-top: 1px solid #444;
        }

        #toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            z-index: 1000;
        }
    </style>
</head>

<body>

    <div id="sidebar">
        <div style="padding: 15px; border-bottom: 1px solid #444;">
            <h3 style="margin: 0 0 10px 0;">èµ„æºç®¡ç†å™¨</h3>
            <div style="display: flex; gap: 5px; margin-bottom: 8px;">
                <button id="btn-single" style="flex: 1;" title="å¤„ç†å•ä¸ªæ–‡ä»¶">ğŸ“„ å•æ–‡ä»¶</button>
                <button id="btn-input" style="flex: 1;" title="æ‰¹é‡å¤„ç†ç›®å½•">ğŸ“‚ ç›®å½•</button>
            </div>
            <button id="btn-output" style="width: 100%; display: none;" title="æ‰¹é‡æ¨¡å¼éœ€è¦é€‰æ‹©è¾“å‡ºç›®å½•">ğŸ’¾ é€‰æ‹©è¾“å‡ºç›®å½•</button>
        </div>
        <ul id="file-list">
            <li style="text-align:center; color:#666; padding:20px;">é€‰æ‹©å•æ–‡ä»¶æˆ–ç›®å½•å¼€å§‹</li>
        </ul>
        <div class="status-bar" id="file-count">0 å¼ å›¾ç‰‡</div>
    </div>

    <div id="main-area">
        <div id="canvas-wrapper">
            <canvas id="main-canvas"></canvas>
            <canvas id="interaction-layer"></canvas>
        </div>
        <div id="toast">æç¤ºæ¶ˆæ¯</div>
    </div>

    <div id="toolbar">
        <div class="control-group">
            <h4>16:9 å¤„ç†æ¨¡å¼</h4>
            <label><input type="radio" name="crop-mode" value="pad" checked> å¡«å…… (Pad)</label>
            <div style="font-size:12px; color:#aaa; margin-left:24px; margin-bottom:5px;">ä¸¤è¾¹å¡«å……èƒŒæ™¯è‰²ï¼Œä¿æŒå…¨å›¾ã€‚</div>
            <label><input type="radio" name="crop-mode" value="crop"> è£å‰ª (Crop)</label>
            <div style="font-size:12px; color:#aaa; margin-left:24px;">æ‹–åŠ¨é€‰æ¡†æˆªå–å±€éƒ¨ã€‚</div>
        </div>

        <div class="control-group">
            <h4>ğŸ’§ å»æ°´å° (åŒé€‰æ¡†æ¨¡å¼)</h4>
            <div style="font-size:12px; color:#aaa; margin-bottom:10px;">
                1. å…ˆç”»<b style="color:#4a90e2;">å¤–æ¡†</b>ï¼ˆé‡‡æ ·é¢œè‰²åŒºåŸŸï¼‰<br>
                2. å†ç”»<b style="color:#e24a4a;">å†…æ¡†</b>ï¼ˆæ°´å°åŒºåŸŸï¼Œå°†è¢«å¡«å……ï¼‰
            </div>
            <div id="watermark-status"
                style="padding:8px; background:#444; border-radius:4px; font-size:13px; margin-bottom:8px;">
                å½“å‰çŠ¶æ€ï¼šç­‰å¾…ç»˜åˆ¶å¤–æ¡†...
            </div>
            <button id="btn-clear-mask" style="width:100%; margin-top:5px;">æ¸…é™¤é€‰æ¡†é‡æ–°å¼€å§‹</button>
            <div style="margin-top:10px; border-top:1px solid #555; padding-top:10px;">
                <label><input type="checkbox" id="chk-persist-mask" checked> <b>ä¿ç•™é€‰æ¡†ä½ç½®</b></label>
                <div style="font-size:12px; color:#aaa; margin-left:24px;">å‹¾é€‰åï¼Œä¸‹ä¸€å¼ å›¾ç‰‡ä¼šè‡ªåŠ¨åº”ç”¨ç›¸åŒçš„å»æ°´å°åŒºåŸŸï¼ˆé€‚åˆæ‰¹é‡å¤„ç†ï¼‰ã€‚</div>
            </div>
        </div>

        <div class="control-group">
            <h4>æ“ä½œ</h4>
            <button id="btn-save" class="primary" style="width:100%; height:40px; font-weight:bold;">ä¿å­˜å¹¶ä¸‹ä¸€å¼  (S)</button>
            <button id="btn-download" style="width:100%; margin-top:5px; display:none;">â¬‡ï¸ ä¸‹è½½åˆ°æœ¬åœ°</button>
            <label style="margin-top:10px;"><input type="checkbox" id="chk-auto-save"> è‡ªåŠ¨ä¿å­˜</label>
        </div>

        <div style="flex:1;"></div>
        <div style="font-size:12px; color:#666;">
            å¿«æ·é”®ï¼š<br>
            â† / â†’ : åˆ‡æ¢å›¾ç‰‡<br>
            S : ä¿å­˜å½“å‰<br>
            C : æ¸…é™¤é€‰æ¡†
        </div>
    </div>

    <script>
        // === çŠ¶æ€ç®¡ç† ===
        const state = {
            inputHandle: null,
            outputHandle: null,
            files: [], // { name, handle }
            currentIndex: -1,
            currentImage: null, // Image Object
            currentFileName: '', // å½“å‰æ–‡ä»¶å
            isSingleFileMode: false, // å•æ–‡ä»¶æ¨¡å¼
            mode: 'pad', // 'pad' or 'crop'
            cropRect: { x: 0, y: 0, w: 0, h: 0 }, // è£å‰ªæ¨¡å¼ä¸‹çš„é€‰æ¡†
            // å»æ°´å°åŒé€‰æ¡†
            watermarkOuter: null, // { x, y, w, h } - å½’ä¸€åŒ–åæ ‡ (0-1)
            watermarkInner: null, // { x, y, w, h } - å½’ä¸€åŒ–åæ ‡ (0-1)
            watermarkStep: 'outer', // 'outer' | 'inner' | 'done'
            isDrawingRect: false,
            rectStart: { x: 0, y: 0 },
        };

        // DOM å…ƒç´ 
        const els = {
            singleBtn: document.getElementById('btn-single'),
            inputBtn: document.getElementById('btn-input'),
            outputBtn: document.getElementById('btn-output'),
            downloadBtn: document.getElementById('btn-download'),
            fileList: document.getElementById('file-list'),
            fileCount: document.getElementById('file-count'),
            mainCanvas: document.getElementById('main-canvas'),
            layerCanvas: document.getElementById('interaction-layer'),
            ctxMain: document.getElementById('main-canvas').getContext('2d'),
            ctxLayer: document.getElementById('interaction-layer').getContext('2d'),
            radioModes: document.getElementsByName('crop-mode'),
            clearMaskBtn: document.getElementById('btn-clear-mask'),
            persistChk: document.getElementById('chk-persist-mask'),
            saveBtn: document.getElementById('btn-save'),
            toast: document.getElementById('toast'),
            watermarkStatus: document.getElementById('watermark-status')
        };

        // === 1. æ–‡ä»¶ç³»ç»Ÿæ“ä½œ ===

        // å•æ–‡ä»¶æ¨¡å¼
        els.singleBtn.onclick = async () => {
            try {
                const [fileHandle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'å›¾ç‰‡æ–‡ä»¶',
                        accept: { 'image/*': ['.jpg', '.jpeg', '.png', '.webp'] }
                    }],
                    multiple: false
                });
                await loadSingleFile(fileHandle);
            } catch (err) { console.error(err); }
        };

        // æ‰¹é‡æ¨¡å¼
        els.inputBtn.onclick = async () => {
            try {
                state.inputHandle = await window.showDirectoryPicker();
                state.isSingleFileMode = false;
                els.outputBtn.style.display = 'block';
                els.downloadBtn.style.display = 'none';
                els.saveBtn.textContent = 'ä¿å­˜å¹¶ä¸‹ä¸€å¼  (S)';
                await loadFileList();
            } catch (err) { console.error(err); }
        };

        els.outputBtn.onclick = async () => {
            try {
                state.outputHandle = await window.showDirectoryPicker();
                showToast("è¾“å‡ºç›®å½•å·²è®¾å®š");
            } catch (err) { console.error(err); }
        };

        // åŠ è½½å•ä¸ªæ–‡ä»¶
        async function loadSingleFile(fileHandle) {
            state.isSingleFileMode = true;
            state.files = [{ name: fileHandle.name, handle: fileHandle }];
            state.currentIndex = 0;
            state.currentFileName = fileHandle.name;

            // æ›´æ–° UI
            els.outputBtn.style.display = 'none';
            els.downloadBtn.style.display = 'block';
            els.saveBtn.textContent = 'ä¿å­˜ (S)';

            els.fileList.innerHTML = '';
            const li = document.createElement('li');
            li.textContent = fileHandle.name;
            li.classList.add('active');
            els.fileList.appendChild(li);
            els.fileCount.textContent = 'å•æ–‡ä»¶æ¨¡å¼';

            // è¯»å–å¹¶æ˜¾ç¤ºæ–‡ä»¶
            const file = await fileHandle.getFile();
            const bmp = await createImageBitmap(file);
            state.currentImage = bmp;

            // é‡ç½®é€‰æ¡†
            if (!els.persistChk.checked) {
                state.watermarkOuter = null;
                state.watermarkInner = null;
                state.watermarkStep = 'outer';
            }
            updateWatermarkStatus();
            initCropRect();
            render();
        }

        async function loadFileList() {
            state.files = [];
            els.fileList.innerHTML = '';

            for await (const entry of state.inputHandle.values()) {
                if (entry.kind === 'file' && /\.(jpg|jpeg|png|webp)$/i.test(entry.name)) {
                    state.files.push({ name: entry.name, handle: entry });
                }
            }

            // æ’åº
            state.files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

            // æ¸²æŸ“åˆ—è¡¨
            state.files.forEach((f, i) => {
                const li = document.createElement('li');
                li.textContent = f.name;
                li.onclick = () => loadFile(i);
                els.fileList.appendChild(li);
            });

            els.fileCount.textContent = `${state.files.length} å¼ å›¾ç‰‡`;
            if (state.files.length > 0) loadFile(0);
        }

        async function loadFile(index) {
            if (index < 0 || index >= state.files.length) return;

            // UI æ›´æ–°
            const items = els.fileList.children;
            if (state.currentIndex >= 0 && items[state.currentIndex]) items[state.currentIndex].classList.remove('active');
            state.currentIndex = index;
            items[index].classList.add('active');
            items[index].scrollIntoView({ block: 'nearest' });

            // è¯»å–æ–‡ä»¶
            const file = await state.files[index].handle.getFile();
            const bmp = await createImageBitmap(file);

            state.currentImage = bmp;

            // é®ç½©å¤„ç†ï¼šå¦‚æœä¸ä¿ç•™ï¼Œåˆ™æ¸…ç©º
            if (!els.persistChk.checked) {
                state.watermarkOuter = null;
                state.watermarkInner = null;
                state.watermarkStep = 'outer';
            }
            updateWatermarkStatus();

            // åˆå§‹åŒ–è£å‰ªæ¡† (é»˜è®¤å±…ä¸­)
            initCropRect();

            render();
        }

        function initCropRect() {
            if (!state.currentImage) return;
            const imgW = state.currentImage.width;
            const imgH = state.currentImage.height;

            // ç›®æ ‡æ˜¯ 16:9
            // å¦‚æœæ˜¯è£å‰ªæ¨¡å¼ï¼Œåˆå§‹åŒ–ä¸€ä¸ªæœ€å¤§çš„ 16:9 æ¡†
            let targetW = imgW;
            let targetH = targetW * (9 / 16);
            if (targetH > imgH) {
                targetH = imgH;
                targetW = targetH * (16 / 9);
            }

            state.cropRect = {
                x: (imgW - targetW) / 2,
                y: (imgH - targetH) / 2,
                w: targetW,
                h: targetH
            };
        }

        // === 2. æ¸²æŸ“é€»è¾‘ ===

        // ç›‘å¬æ¨¡å¼åˆ‡æ¢
        els.radioModes.forEach(r => r.addEventListener('change', (e) => {
            state.mode = e.target.value;
            render();
        }));

        function render() {
            if (!state.currentImage) return;

            // 1. è®¾ç½®ç”»å¸ƒå°ºå¯¸
            // è¿™é‡Œçš„é€»è¾‘æ˜¯ï¼šMainCanvas å§‹ç»ˆä½œä¸º"æœ€ç»ˆè¾“å‡ºé¢„è§ˆ"
            // Pad æ¨¡å¼ä¸‹ï¼šMainCanvas æ˜¯ 16:9 çš„æ‰©å……å›¾
            // Crop æ¨¡å¼ä¸‹ï¼šMainCanvas æ˜¾ç¤ºåŸå›¾ï¼Œç”¨ InteractionLayer æ˜¾ç¤ºè£å‰ªæ¡†
            // ä¸ºäº†ç®€åŒ–ç»Ÿä¸€ï¼Œæˆ‘ä»¬åœ¨ MainCanvas ä¸Šæ€»æ˜¯ç»˜åˆ¶"æ‰€è§å³æ‰€å¾—"çš„ç»“æœä¸å¤ªå®¹æ˜“ï¼Œ
            // ç­–ç•¥ï¼šMainCanvas ç»˜åˆ¶åº•å›¾ï¼ˆåŸå›¾ï¼‰ï¼Œæˆ‘ä»¬åœ¨ä¿å­˜æ—¶å†åšçœŸæ­£çš„è£åˆ‡/å¡«å……ã€‚
            // åªæœ‰è¿™æ ·ï¼Œå»æ°´å°çš„ç¬”åˆ·åæ ‡æ‰èƒ½ç»Ÿä¸€å¯¹åº”åˆ°åŸå›¾ä¸Šã€‚

            const img = state.currentImage;
            els.mainCanvas.width = img.width;
            els.mainCanvas.height = img.height;
            els.layerCanvas.width = img.width;
            els.layerCanvas.height = img.height;

            // ç»˜åˆ¶åŸå›¾
            els.ctxMain.drawImage(img, 0, 0);

            // 2. åº”ç”¨å»æ°´å° (ç®€å•çš„å‘¨å›´å¡«å……ç®—æ³•)
            applyInpainting();

            // 3. ç»˜åˆ¶äº¤äº’å±‚ (è£å‰ªæ¡†)
            drawOverlay();
        }

        function applyInpainting() {
            // æ–°é€»è¾‘ï¼šç”¨å¤–æ¡†é‡‡æ ·çš„é¢œè‰²å®Œå…¨å¡«å……å†…æ¡†åŒºåŸŸ
            if (!state.watermarkOuter || !state.watermarkInner) return;

            const ctx = els.ctxMain;
            const imgW = els.mainCanvas.width;
            const imgH = els.mainCanvas.height;

            // è¿˜åŸå¤–æ¡†åæ ‡ï¼ˆå½’ä¸€åŒ– -> åƒç´ ï¼‰
            const outer = {
                x: state.watermarkOuter.x * imgW,
                y: state.watermarkOuter.y * imgH,
                w: state.watermarkOuter.w * imgW,
                h: state.watermarkOuter.h * imgH
            };

            // è¿˜åŸå†…æ¡†åæ ‡
            const inner = {
                x: state.watermarkInner.x * imgW,
                y: state.watermarkInner.y * imgH,
                w: state.watermarkInner.w * imgW,
                h: state.watermarkInner.h * imgH
            };

            // ä»å¤–æ¡†åŒºåŸŸé‡‡æ ·é¢œè‰²ï¼ˆæ’é™¤å†…æ¡†åŒºåŸŸï¼‰
            // ä¸ºäº†æ€§èƒ½ï¼Œé‡‡æ ·å¤–æ¡†å››ä¸ªè§’å’Œå››æ¡è¾¹ä¸­ç‚¹
            let rTotal = 0, gTotal = 0, bTotal = 0, count = 0;

            // é‡‡æ ·ç‚¹ï¼šå¤–æ¡†çš„è¾¹ç¼˜åŒºåŸŸ
            const samplePoints = [
                // å››è§’
                { x: outer.x + 2, y: outer.y + 2 },
                { x: outer.x + outer.w - 2, y: outer.y + 2 },
                { x: outer.x + 2, y: outer.y + outer.h - 2 },
                { x: outer.x + outer.w - 2, y: outer.y + outer.h - 2 },
                // å››æ¡è¾¹ä¸­ç‚¹
                { x: outer.x + outer.w / 2, y: outer.y + 2 },
                { x: outer.x + outer.w / 2, y: outer.y + outer.h - 2 },
                { x: outer.x + 2, y: outer.y + outer.h / 2 },
                { x: outer.x + outer.w - 2, y: outer.y + outer.h / 2 }
            ];

            samplePoints.forEach(pt => {
                const sx = Math.floor(pt.x);
                const sy = Math.floor(pt.y);
                if (sx >= 0 && sx < imgW && sy >= 0 && sy < imgH) {
                    const pixel = ctx.getImageData(sx, sy, 1, 1).data;
                    rTotal += pixel[0];
                    gTotal += pixel[1];
                    bTotal += pixel[2];
                    count++;
                }
            });

            if (count > 0) {
                // ç”¨é‡‡æ ·é¢œè‰²å®Œå…¨å¡«å……å†…æ¡†
                ctx.fillStyle = `rgb(${Math.round(rTotal / count)}, ${Math.round(gTotal / count)}, ${Math.round(bTotal / count)})`;
                ctx.fillRect(inner.x, inner.y, inner.w, inner.h);
            }
        }

        function drawOverlay() {
            const ctx = els.ctxLayer;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // è£å‰ªæ¨¡å¼ä¸‹ç»˜åˆ¶é®ç½©
            if (state.mode === 'crop') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // æŒ–ç©ºé€‰ä¸­åŒºåŸŸ
                const { x, y, w, h } = state.cropRect;
                ctx.clearRect(x, y, w, h);

                // ç»˜åˆ¶è¾¹æ¡†
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                // ç»˜åˆ¶ä¸‰åˆ†çº¿ (è¾…åŠ©æ„å›¾)
                ctx.beginPath();
                ctx.moveTo(x + w / 3, y); ctx.lineTo(x + w / 3, y + h);
                ctx.moveTo(x + 2 * w / 3, y); ctx.lineTo(x + 2 * w / 3, y + h);
                ctx.moveTo(x, y + h / 3); ctx.lineTo(x + w, y + h / 3);
                ctx.moveTo(x, y + 2 * h / 3); ctx.lineTo(x + w, y + 2 * h / 3);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.stroke();
            } else {
                // Pad æ¨¡å¼ä¸‹ï¼Œæç¤ºæœ€ç»ˆèŒƒå›´ï¼ˆè™½ç„¶æ˜¯å…¨å›¾ï¼Œä½†ç»™ä¸ªè¾¹æ¡†æç¤ºï¼‰
                // Pad æ¨¡å¼å…¶å®ä¸éœ€è¦ overlayï¼Œé™¤éæˆ‘ä»¬æƒ³é¢„è§ˆå¡«å……åçš„æ•ˆæœ
                // ç®€å•èµ·è§ï¼ŒPad æ¨¡å¼ä¸æ˜¾ç¤ºç‰¹æ®Š Overlayï¼Œåªæ˜¾ç¤ºç¬”åˆ·
            }

            // ç»˜åˆ¶ç¬”åˆ·å…‰æ ‡ (å¦‚æœé¼ æ ‡åœ¨ç”»å¸ƒä¸Š)
            // (ç”± mousemove å¤„ç†)
        }


        // === 3. äº¤äº’é€»è¾‘ (åŒé€‰æ¡†å»æ°´å° + è£å‰ª) ===

        // æ›´æ–°å»æ°´å°çŠ¶æ€æç¤º
        function updateWatermarkStatus() {
            if (!els.watermarkStatus) return;
            if (state.watermarkStep === 'outer') {
                els.watermarkStatus.innerHTML = 'å½“å‰çŠ¶æ€ï¼š<span style="color:#4a90e2;">è¯·ç»˜åˆ¶å¤–æ¡†</span>ï¼ˆé‡‡æ ·é¢œè‰²åŒºåŸŸï¼‰';
            } else if (state.watermarkStep === 'inner') {
                els.watermarkStatus.innerHTML = 'å½“å‰çŠ¶æ€ï¼š<span style="color:#e24a4a;">è¯·ç»˜åˆ¶å†…æ¡†</span>ï¼ˆæ°´å°åŒºåŸŸï¼‰';
            } else {
                els.watermarkStatus.innerHTML = 'å½“å‰çŠ¶æ€ï¼š<span style="color:#4ae24a;">âœ“ å»æ°´å°å·²å®Œæˆ</span>';
            }
        }

        // æ¸…é™¤é€‰æ¡†
        els.clearMaskBtn.onclick = () => {
            state.watermarkOuter = null;
            state.watermarkInner = null;
            state.watermarkStep = 'outer';
            updateWatermarkStatus();
            render();
        };

        // é¼ æ ‡äº‹ä»¶
        let isDraggingCrop = false;
        let lastMouse = { x: 0, y: 0 };
        let tempRect = null; // ä¸´æ—¶ç»˜åˆ¶çš„é€‰æ¡†

        els.layerCanvas.addEventListener('mousedown', (e) => {
            const rect = els.layerCanvas.getBoundingClientRect();
            const scaleX = els.layerCanvas.width / rect.width;
            const scaleY = els.layerCanvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            if (state.mode === 'crop') {
                // è£å‰ªæ¨¡å¼ï¼šæ‹–åŠ¨é€‰æ¡†
                if (mx >= state.cropRect.x && mx <= state.cropRect.x + state.cropRect.w &&
                    my >= state.cropRect.y && my <= state.cropRect.y + state.cropRect.h) {
                    isDraggingCrop = true;
                    lastMouse = { x: mx, y: my };
                }
            } else {
                // Pad æ¨¡å¼ï¼šåŒé€‰æ¡†å»æ°´å°
                if (state.watermarkStep !== 'done') {
                    state.isDrawingRect = true;
                    state.rectStart = { x: mx, y: my };
                    tempRect = { x: mx, y: my, w: 0, h: 0 };
                }
            }
        });

        els.layerCanvas.addEventListener('mousemove', (e) => {
            const rect = els.layerCanvas.getBoundingClientRect();
            const scaleX = els.layerCanvas.width / rect.width;
            const scaleY = els.layerCanvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            // é‡ç»˜äº¤äº’å±‚
            drawOverlay();
            const ctx = els.ctxLayer;

            if (state.mode === 'crop' && isDraggingCrop) {
                const dx = mx - lastMouse.x;
                const dy = my - lastMouse.y;
                state.cropRect.x += dx;
                state.cropRect.y += dy;

                // é™åˆ¶è¾¹ç•Œ
                const cw = els.layerCanvas.width;
                const ch = els.layerCanvas.height;
                if (state.cropRect.x < 0) state.cropRect.x = 0;
                if (state.cropRect.y < 0) state.cropRect.y = 0;
                if (state.cropRect.x + state.cropRect.w > cw) state.cropRect.x = cw - state.cropRect.w;
                if (state.cropRect.y + state.cropRect.h > ch) state.cropRect.y = ch - state.cropRect.h;
                lastMouse = { x: mx, y: my };
                drawOverlay();
            } else if (state.isDrawingRect && state.mode === 'pad') {
                // ç»˜åˆ¶ä¸´æ—¶é€‰æ¡†é¢„è§ˆ
                tempRect = {
                    x: Math.min(state.rectStart.x, mx),
                    y: Math.min(state.rectStart.y, my),
                    w: Math.abs(mx - state.rectStart.x),
                    h: Math.abs(my - state.rectStart.y)
                };

                // ç»˜åˆ¶ä¸´æ—¶é€‰æ¡†
                ctx.strokeStyle = state.watermarkStep === 'outer' ? '#4a90e2' : '#e24a4a';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(tempRect.x, tempRect.y, tempRect.w, tempRect.h);
                ctx.setLineDash([]);
            }

            // ç»˜åˆ¶å·²æœ‰çš„é€‰æ¡†
            drawWatermarkRects(ctx);
        });

        window.addEventListener('mouseup', (e) => {
            if (state.isDrawingRect && tempRect && tempRect.w > 5 && tempRect.h > 5) {
                const img = state.currentImage;
                if (img) {
                    // å½’ä¸€åŒ–å­˜å‚¨
                    const normalizedRect = {
                        x: tempRect.x / img.width,
                        y: tempRect.y / img.height,
                        w: tempRect.w / img.width,
                        h: tempRect.h / img.height
                    };

                    if (state.watermarkStep === 'outer') {
                        state.watermarkOuter = normalizedRect;
                        state.watermarkStep = 'inner';
                    } else if (state.watermarkStep === 'inner') {
                        state.watermarkInner = normalizedRect;
                        state.watermarkStep = 'done';
                    }
                    updateWatermarkStatus();
                }
            }

            state.isDrawingRect = false;
            isDraggingCrop = false;
            tempRect = null;
            if (state.currentImage) render();
        });

        // ç»˜åˆ¶å·²å­˜åœ¨çš„å»æ°´å°é€‰æ¡†
        function drawWatermarkRects(ctx) {
            const img = state.currentImage;
            if (!img) return;

            // ç»˜åˆ¶å¤–æ¡†ï¼ˆè“è‰²ï¼‰
            if (state.watermarkOuter) {
                const outer = {
                    x: state.watermarkOuter.x * img.width,
                    y: state.watermarkOuter.y * img.height,
                    w: state.watermarkOuter.w * img.width,
                    h: state.watermarkOuter.h * img.height
                };
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                ctx.strokeRect(outer.x, outer.y, outer.w, outer.h);

                // æ ‡æ³¨"å¤–æ¡†"
                ctx.fillStyle = '#4a90e2';
                ctx.font = '14px sans-serif';
                ctx.fillText('å¤–æ¡† (é‡‡æ ·)', outer.x + 4, outer.y + 16);
            }

            // ç»˜åˆ¶å†…æ¡†ï¼ˆçº¢è‰²ï¼‰
            if (state.watermarkInner) {
                const inner = {
                    x: state.watermarkInner.x * img.width,
                    y: state.watermarkInner.y * img.height,
                    w: state.watermarkInner.w * img.width,
                    h: state.watermarkInner.h * img.height
                };
                ctx.strokeStyle = '#e24a4a';
                ctx.lineWidth = 2;
                ctx.strokeRect(inner.x, inner.y, inner.w, inner.h);

                // æ ‡æ³¨"å†…æ¡†"
                ctx.fillStyle = '#e24a4a';
                ctx.font = '14px sans-serif';
                ctx.fillText('å†…æ¡† (å¡«å……)', inner.x + 4, inner.y + 16);
            }
        }


        // === 4. ä¿å­˜é€»è¾‘ ===

        els.saveBtn.onclick = processAndSave;
        els.downloadBtn.onclick = downloadToLocal;

        // ç”Ÿæˆå¤„ç†åçš„å›¾åƒï¼ˆå…±ç”¨é€»è¾‘ï¼‰
        function generateProcessedImage() {
            if (!state.currentImage) return null;

            const img = state.currentImage;
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');

            let finalW, finalH;

            if (state.mode === 'pad') {
                const ratio = 16 / 9;
                if (img.width / img.height < ratio) {
                    finalH = img.height;
                    finalW = finalH * ratio;
                } else {
                    finalW = img.width;
                    finalH = finalW / ratio;
                }

                offCanvas.width = finalW;
                offCanvas.height = finalH;

                const pixel = els.ctxMain.getImageData(0, 0, 1, 1).data;
                offCtx.fillStyle = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
                offCtx.fillRect(0, 0, finalW, finalH);

                const dx = (finalW - img.width) / 2;
                const dy = (finalH - img.height) / 2;
                offCtx.drawImage(els.mainCanvas, dx, dy);
            } else {
                offCanvas.width = state.cropRect.w;
                offCanvas.height = state.cropRect.h;
                offCtx.drawImage(els.mainCanvas,
                    state.cropRect.x, state.cropRect.y, state.cropRect.w, state.cropRect.h,
                    0, 0, state.cropRect.w, state.cropRect.h
                );
            }

            return offCanvas;
        }

        // ä¸‹è½½åˆ°æœ¬åœ°ï¼ˆå•æ–‡ä»¶æ¨¡å¼ï¼‰
        async function downloadToLocal() {
            const offCanvas = generateProcessedImage();
            if (!offCanvas) return;

            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, 'image/jpeg', 0.95));
                const filename = state.currentFileName.replace(/\.[^.]+$/, '_processed.jpg');

                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast(`å·²ä¸‹è½½: ${filename}`);
            } catch (err) {
                console.error(err);
                alert("ä¸‹è½½å¤±è´¥");
            }
        }

        // ä¿å­˜åˆ°è¾“å‡ºç›®å½•ï¼ˆæ‰¹é‡æ¨¡å¼ï¼‰
        async function processAndSave() {
            // å•æ–‡ä»¶æ¨¡å¼ç›´æ¥ä¸‹è½½
            if (state.isSingleFileMode) {
                await downloadToLocal();
                return;
            }

            if (!state.currentImage) return;
            if (!state.outputHandle) {
                alert("è¯·å…ˆé€‰æ‹©è¾“å‡ºç›®å½•ï¼");
                return;
            }

            const offCanvas = generateProcessedImage();
            if (!offCanvas) return;

            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, 'image/jpeg', 0.95));
                const filename = state.files[state.currentIndex].name;

                const newFileHandle = await state.outputHandle.getFileHandle(filename, { create: true });
                const writable = await newFileHandle.createWritable();
                await writable.write(blob);
                await writable.close();

                showToast(`å·²ä¿å­˜: ${filename}`);

                if (state.currentIndex < state.files.length - 1) {
                    loadFile(state.currentIndex + 1);
                } else {
                    showToast("æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæ¯•ï¼");
                }
            } catch (err) {
                console.error(err);
                alert("ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç›®å½•æƒé™");
            }
        }

        // === è¾…åŠ© ===

        function showToast(msg) {
            els.toast.textContent = msg;
            els.toast.style.display = 'block';
            setTimeout(() => els.toast.style.display = 'none', 2000);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') loadFile(state.currentIndex + 1);
            if (e.key === 'ArrowLeft') loadFile(state.currentIndex - 1);
            if (e.key.toLowerCase() === 's') processAndSave();
            if (e.key.toLowerCase() === 'c') {
                // å¿«æ·é”®æ¸…é™¤é€‰æ¡†
                state.watermarkOuter = null;
                state.watermarkInner = null;
                state.watermarkStep = 'outer';
                updateWatermarkStatus();
                render();
            }
        });

    </script>
</body>

</html>