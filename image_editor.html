<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾ç‰‡å¤„ç† - LocalForge</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Global Styles -->
    <link rel="stylesheet" href="css/style.css">
    <style>
        body {
            overflow: hidden;
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: {
                            850: '#1e293b',
                        }
                    }
                }
            }
        }
    </script>
    <!-- Custom Components -->
    <script type="module" src="js/components.js"></script>
</head>

<body
    class="bg-slate-50 dark:bg-slate-900 text-slate-900 dark:text-slate-200 font-sans h-screen flex overflow-hidden transition-colors duration-300">

    <local-sidebar></local-sidebar>

    <div class="flex-1 flex flex-col min-w-0">
        <!-- Header -->
        <local-header title="å›¾ç‰‡å¤„ç†å·¥å…·">
            <i slot="icon" class="fas fa-image text-blue-500"></i>
            <div slot="actions" class="text-xs text-slate-500 dark:text-slate-400">16:9 è£å‰ª & å»æ°´å°</div>
        </local-header>

        <!-- Main Content -->
        <div class="flex-1 flex overflow-hidden">

            <!-- Left Sidebar: File List -->
            <aside
                class="w-64 bg-white dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 flex flex-col shrink-0 z-10 transition-colors duration-300">
                <div class="p-4 border-b border-slate-200 dark:border-slate-700">
                    <h3 class="text-sm font-bold text-slate-500 dark:text-slate-400 mb-3 uppercase tracking-wider">èµ„æºç®¡ç†å™¨
                    </h3>
                    <div class="flex gap-2 mb-2">
                        <button id="btn-single"
                            class="flex-1 px-3 py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded text-xs text-slate-700 dark:text-white transition border border-slate-200 dark:border-slate-600 hover:border-slate-300 dark:hover:border-slate-500">ğŸ“„
                            å•æ–‡ä»¶</button>
                        <button id="btn-input"
                            class="flex-1 px-3 py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded text-xs text-slate-700 dark:text-white transition border border-slate-200 dark:border-slate-600 hover:border-slate-300 dark:hover:border-slate-500">ğŸ“‚
                            ç›®å½•</button>
                    </div>
                    <button id="btn-output"
                        class="w-full px-3 py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 rounded text-xs text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition border border-slate-200 dark:border-slate-600 hover:border-slate-300 dark:hover:border-slate-500 hidden mb-1">ğŸ’¾
                        é€‰æ‹©è¾“å‡ºç›®å½•</button>
                    <div id="output-info" class="text-[10px] text-slate-500 truncate mt-1">é»˜è®¤: Downloads</div>
                </div>

                <ul id="file-list" class="flex-1 overflow-y-auto p-2 space-y-1">
                    <li
                        class="p-4 text-center text-slate-400 dark:text-slate-500 text-xs border border-dashed border-slate-300 dark:border-slate-700 rounded select-none">
                        è¯·é€‰æ‹©æ–‡ä»¶æˆ–ç›®å½•</li>
                </ul>

                <div class="p-2 border-t border-slate-200 dark:border-slate-700 text-center text-[10px] text-slate-400 dark:text-slate-500"
                    id="file-count">0 å¼ å›¾ç‰‡
                </div>
            </aside>

            <!-- Center: Canvas -->
            <main
                class="flex-1 bg-slate-50 dark:bg-slate-900/50 flex flex-col relative overflow-hidden transition-colors duration-300">
                <!-- Filename Display -->
                <div id="filename-bar"
                    class="h-10 bg-white dark:bg-slate-800/90 border-b border-slate-200 dark:border-slate-700 flex items-center justify-center px-4 shrink-0 transition-colors duration-300">
                    <span id="current-filename"
                        class="text-sm font-medium text-blue-600 dark:text-blue-400 truncate max-w-full">æœªé€‰æ‹©æ–‡ä»¶</span>
                </div>
                <div
                    class="flex-1 flex items-center justify-center p-8 overflow-hidden bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTAgMGgxMHYxMEgwem0xMCAxMGgxMHYxMEgxMHoiIGZpbGw9IiMzMzMiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+')] dark:bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTAgMGgxMHYxMEgwem0xMCAxMGgxMHYxMEgxMHoiIGZpbGw9IiMzMzMiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+')]">
                    <div id="canvas-wrapper"
                        class="relative shadow-2xl shadow-black/20 dark:shadow-black/50 border border-slate-200 dark:border-slate-700/50 bg-[#f0f0f0] dark:bg-[#111]">
                        <canvas id="main-canvas" class="block max-w-full max-h-[75vh]"></canvas>
                        <canvas id="interaction-layer"
                            class="absolute top-0 left-0 w-full h-full cursor-crosshair touch-none"></canvas>
                    </div>
                </div>

                <!-- Toast -->
                <div id="toast"
                    class="absolute top-14 left-1/2 -translate-x-1/2 bg-white dark:bg-slate-800 text-slate-800 dark:text-white px-4 py-2 rounded-full text-xs shadow-xl border border-slate-200 dark:border-slate-700 hidden transition-opacity z-50 flex items-center gap-2">
                    <i class="fas fa-info-circle text-blue-500 dark:text-blue-400"></i> <span>æç¤ºæ¶ˆæ¯</span>
                </div>
            </main>

            <!-- Right Toolbar -->
            <aside
                class="w-64 bg-white dark:bg-slate-800 border-l border-slate-200 dark:border-slate-700 flex flex-col shrink-0 overflow-y-auto z-10 transition-colors duration-300">
                <div class="p-3 space-y-4">

                    <!-- Crop Mode - Horizontal Layout -->
                    <div class="space-y-2">
                        <h4 class="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider">æ¨¡å¼
                        </h4>
                        <div class="flex gap-2">
                            <label class="flex-1 cursor-pointer">
                                <input type="radio" name="crop-mode" value="pad" checked class="hidden peer">
                                <div
                                    class="py-2 text-center text-xs font-medium text-slate-500 dark:text-slate-400 bg-slate-100 dark:bg-slate-900/50 border border-slate-200 dark:border-slate-700/50 rounded-lg peer-checked:bg-blue-100 dark:peer-checked:bg-blue-600/20 peer-checked:border-blue-500 peer-checked:text-blue-600 dark:peer-checked:text-blue-400 transition">
                                    Pad
                                </div>
                            </label>
                            <label class="flex-1 cursor-pointer">
                                <input type="radio" name="crop-mode" value="crop" class="hidden peer">
                                <div
                                    class="py-2 text-center text-xs font-medium text-slate-500 dark:text-slate-400 bg-slate-100 dark:bg-slate-900/50 border border-slate-200 dark:border-slate-700/50 rounded-lg peer-checked:bg-blue-100 dark:peer-checked:bg-blue-600/20 peer-checked:border-blue-500 peer-checked:text-blue-600 dark:peer-checked:text-blue-400 transition">
                                    Crop
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Gemini Auto Watermark Removal -->
                    <div class="space-y-2">
                        <h4 class="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider">Gemini
                            å»æ°´å°</h4>
                        <button id="btn-gemini-watermark"
                            class="w-full py-2 bg-emerald-600 hover:bg-emerald-500 text-white text-xs font-bold rounded border border-emerald-500 transition flex items-center justify-center gap-2">
                            <i class="fas fa-magic"></i>
                            ä¸€é”®å»æ°´å° (G)
                        </button>
                        <div id="gemini-watermark-status"
                            class="px-2 py-1.5 bg-slate-800 rounded border border-slate-700 text-xs text-center hidden">
                        </div>
                    </div>

                    <!-- Watermark (Manual Diamond Mode) -->
                    <div class="space-y-2">
                        <h4 class="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider">æ‰‹åŠ¨å»æ°´å°
                        </h4>
                        <div id="watermark-status"
                            class="px-2 py-1.5 bg-slate-100 dark:bg-slate-800 rounded border border-slate-200 dark:border-slate-700 text-xs text-center text-slate-600 dark:text-slate-300">
                            ç‚¹å‡»æ‹–åŠ¨ç»˜åˆ¶è±å½¢
                        </div>
                        <div class="flex gap-2">
                            <button id="btn-clear-mask"
                                class="flex-1 py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-300 hover:text-slate-900 dark:hover:text-white text-xs rounded border border-slate-200 dark:border-slate-600 transition">
                                æ¸…é™¤ (C)
                            </button>
                            <label
                                class="flex items-center gap-1.5 cursor-pointer text-xs text-slate-500 dark:text-slate-400">
                                <input type="checkbox" id="chk-persist-mask" checked
                                    class="w-3.5 h-3.5 rounded border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-blue-500">
                                ä¿ç•™
                            </label>
                        </div>
                    </div>

                    <!-- Export -->
                    <div class="space-y-2">
                        <h4 class="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider">è¾“å‡º
                        </h4>
                        <div class="flex items-center justify-between">
                            <select id="sel-format"
                                class="bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-600 text-xs text-slate-700 dark:text-white rounded px-2 py-1 outline-none focus:border-blue-500">
                                <option value="image/png" selected>PNG</option>
                                <option value="image/jpeg">JPEG</option>
                            </select>
                            <div id="quality-wrapper" class="flex items-center gap-2">
                                <input type="range" id="rng-quality" min="10" max="100" value="95" step="5"
                                    class="w-16 h-1.5 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                                <span id="quality-val" class="text-xs text-blue-600 dark:text-blue-400 w-8">95%</span>
                            </div>
                        </div>
                    </div>

                    <!-- Actions -->
                    <div class="pt-3 border-t border-slate-200 dark:border-slate-700 space-y-2">
                        <button id="btn-save"
                            class="w-full py-2.5 bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-500 text-white text-sm font-bold rounded-lg shadow-lg shadow-blue-500/20 transition">
                            ğŸ’¾ ä¿å­˜ (S)
                        </button>
                        <button id="btn-save-original"
                            class="w-full py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-300 text-xs rounded border border-slate-200 dark:border-slate-600 transition">
                            ä¿å­˜åŸå›¾ (O)
                        </button>
                        <button id="btn-download"
                            class="w-full py-1.5 bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 text-slate-700 dark:text-white text-xs rounded border border-slate-200 dark:border-slate-600 hidden transition">
                            â¬‡ï¸ ä¸‹è½½åˆ°æœ¬åœ°
                        </button>
                    </div>

                    <div class="text-[10px] text-slate-500 dark:text-slate-600 text-center space-y-1 pb-4">
                        <p>â† / â†’ : åˆ‡æ¢å›¾ç‰‡</p>
                        <p>S : ä¿å­˜ | O : ä¿å­˜åŸå›¾ | C : æ¸…é™¤</p>
                    </div>

                </div>
            </aside>
        </div>
    </div>

    <!-- Hidden Inputs -->
    <input type="file" id="fallback-file" style="display: none;" accept="image/png, image/jpeg, image/webp">
    <input type="file" id="fallback-dir" style="display: none;" webkitdirectory directory multiple>

    <script>
        // === çŠ¶æ€ç®¡ç† ===
        const state = {
            inputHandle: null,
            outputHandle: null,
            files: [], // { name, handle }
            currentIndex: -1,
            currentImage: null, // Image Object
            currentFileName: '', // å½“å‰æ–‡ä»¶å
            isSingleFileMode: false, // å•æ–‡ä»¶æ¨¡å¼
            mode: 'pad', // 'pad' or 'crop'
            outputFormat: 'image/png',
            outputQuality: 0.95,
            cropRect: { x: 0, y: 0, w: 0, h: 0 }, // è£å‰ªæ¨¡å¼ä¸‹çš„é€‰æ¡†
            // å»æ°´å°å•æ¡†æ¨¡å¼
            watermarkRect: null, // { x, y, w, h } - å½’ä¸€åŒ–åæ ‡ (0-1)
            isDrawingRect: false,
            rectStart: { x: 0, y: 0 },
        };

        // DOM å…ƒç´ 
        const els = {
            singleBtn: document.getElementById('btn-single'),
            inputBtn: document.getElementById('btn-input'),
            outputBtn: document.getElementById('btn-output'),
            downloadBtn: document.getElementById('btn-download'),
            fileList: document.getElementById('file-list'),
            fileCount: document.getElementById('file-count'),
            mainCanvas: document.getElementById('main-canvas'),
            layerCanvas: document.getElementById('interaction-layer'),
            ctxMain: document.getElementById('main-canvas').getContext('2d'),
            ctxLayer: document.getElementById('interaction-layer').getContext('2d'),
            radioModes: document.getElementsByName('crop-mode'),
            clearMaskBtn: document.getElementById('btn-clear-mask'),
            persistChk: document.getElementById('chk-persist-mask'),
            saveBtn: document.getElementById('btn-save'),
            saveOriginalBtn: document.getElementById('btn-save-original'),
            toast: document.getElementById('toast'),
            watermarkStatus: document.getElementById('watermark-status'),
            geminiWatermarkBtn: document.getElementById('btn-gemini-watermark'),
            geminiWatermarkStatus: document.getElementById('gemini-watermark-status'),
            fallbackFile: document.getElementById('fallback-file'),
            fallbackDir: document.getElementById('fallback-dir'),
            selFormat: document.getElementById('sel-format'),
            rngQuality: document.getElementById('rng-quality'),
            qualityVal: document.getElementById('quality-val'),
            qualityWrapper: document.getElementById('quality-wrapper'),
            outputInfo: document.getElementById('output-info')
        };

        // === 0. è¾“å‡ºè®¾ç½® ===
        // PNG æ˜¯é»˜è®¤æ ¼å¼ï¼Œåˆå§‹åŒ–æ—¶ç¦ç”¨è´¨é‡æ»‘å—
        els.qualityWrapper.style.opacity = '0.5';
        els.qualityWrapper.style.pointerEvents = 'none';

        els.selFormat.onchange = (e) => {
            state.outputFormat = e.target.value;
            // PNG æ— æŸï¼Œä¸éœ€è¦è´¨é‡æ»‘å—
            if (state.outputFormat === 'image/png') {
                els.qualityWrapper.style.opacity = '0.5';
                els.qualityWrapper.style.pointerEvents = 'none';
            } else {
                els.qualityWrapper.style.opacity = '1';
                els.qualityWrapper.style.pointerEvents = 'auto';
            }
        };

        els.rngQuality.oninput = (e) => {
            const val = parseInt(e.target.value);
            els.qualityVal.textContent = val + '%';
            state.outputQuality = val / 100;
        };

        // === 1. æ–‡ä»¶ç³»ç»Ÿæ“ä½œä¸å…¼å®¹æ€§å¤„ç† ===

        // å•æ–‡ä»¶æ¨¡å¼ç‚¹å‡»
        els.singleBtn.onclick = async () => {
            if ('showOpenFilePicker' in window) {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'å›¾ç‰‡æ–‡ä»¶',
                            accept: { 'image/*': ['.jpg', '.jpeg', '.png', '.webp'] }
                        }],
                        multiple: false
                    });
                    await loadSingleFile(fileHandle);
                } catch (err) {
                    // SecurityError means we are in a context that blocks the API (e.g. iframe)
                    if (err.name === 'SecurityError' || err.name === 'NotAllowedError') {
                        els.fallbackFile.click();
                    } else if (err.name !== 'AbortError') {
                        console.error(err);
                    }
                }
            } else {
                // å›é€€æ¨¡å¼
                els.fallbackFile.click();
            }
        };

        // ç›®å½•æ¨¡å¼ç‚¹å‡»
        els.inputBtn.onclick = async () => {
            if ('showDirectoryPicker' in window) {
                try {
                    state.inputHandle = await window.showDirectoryPicker();
                    setupBatchModeUI();
                    await loadFileList();
                } catch (err) {
                    // SecurityError means we are in a context that blocks the API
                    if (err.name === 'SecurityError' || err.name === 'NotAllowedError') {
                        els.fallbackDir.click();
                    } else if (err.name !== 'AbortError') {
                        console.error(err);
                    }
                }
            } else {
                // å›é€€æ¨¡å¼
                els.fallbackDir.click();
            }
        };

        els.outputBtn.onclick = async () => {
            // è¾“å‡ºç›®å½•å¿…é¡»ä½¿ç”¨ API (fallback æ¨¡å¼ä¸‹ä¸æ”¯æŒæŒ‡å®šç›®å½•)
            try {
                const handle = await window.showDirectoryPicker();
                state.outputHandle = handle;
                els.outputInfo.textContent = `è¾“å‡ºç›®å½•: ${handle.name}`;
                els.outputInfo.style.color = '#4a90e2';
                showToast("è¾“å‡ºç›®å½•å·²è®¾å®š");
            } catch (err) {
                if (err.name === 'SecurityError' || err.name === 'NotAllowedError') {
                    // æƒé™è¢«æ‹’ç»æˆ–è¢« iframe ç­–ç•¥é˜»æ­¢
                    const msg = "âš ï¸ ç³»ç»Ÿæç¤ºï¼šæ— æ³•é€‰æ‹©è‡ªå®šä¹‰æ–‡ä»¶å¤¹\n\n" +
                        "åŸå› ï¼šå½“å‰è¿è¡Œç¯å¢ƒï¼ˆå¦‚ VS Code é¢„è§ˆçª—å£ï¼‰å› å®‰å…¨ç­–ç•¥ç¦æ­¢äº†æ­¤åŠŸèƒ½ã€‚\n\n" +
                        "ğŸ‘‰ è§£å†³æ–¹æ³•ï¼šè¯·åœ¨ Chrome æˆ– Edge æµè§ˆå™¨ä¸­ç›´æ¥æ‰“å¼€æ­¤ .html æ–‡ä»¶ï¼Œå³å¯è§£é™¤é™åˆ¶ã€‚\n\n" +
                        "ï¼ˆå½“å‰æ–‡ä»¶å°†è‡ªåŠ¨ä¿å­˜åˆ°æ‚¨çš„é»˜è®¤ã€ä¸‹è½½ã€‘æ–‡ä»¶å¤¹ï¼‰";
                    alert(msg);

                    // éšè—æŒ‰é’®ä»¥é¿å…å†æ¬¡æŠ¥é”™
                    els.outputBtn.style.display = 'none';
                    els.outputInfo.textContent = 'ä¿å­˜ä½ç½®ï¼šæµè§ˆå™¨é»˜è®¤ Downloads (ç¯å¢ƒé™åˆ¶)';
                    state.outputHandle = null; // ç¡®ä¿æ¸…é™¤
                } else if (err.name !== 'AbortError') {
                    console.error(err);
                }
            }
        };

        // ç›‘å¬å›é€€è¾“å…¥æ¡†å˜åŒ–
        els.fallbackFile.onchange = (e) => {
            const file = e.target.files[0];
            if (file) loadSingleFile(file);
            e.target.value = ''; // é‡ç½®ä»¥ä¾¿é‡å¤é€‰æ‹©
        };

        els.fallbackDir.onchange = (e) => {
            if (e.target.files && e.target.files.length > 0) {
                // å°† FileList è½¬ä¸ºæ•°ç»„å­˜å‚¨
                state.inputHandle = Array.from(e.target.files);
                setupBatchModeUI();
                loadFileList(); // åŠ è½½åˆ—è¡¨
            }
            e.target.value = '';
        };

        function setupBatchModeUI() {
            state.isSingleFileMode = false;

            // æ£€æŸ¥æ˜¯å¦æ”¯æŒ DirectoryPicker ä»¥å†³å®šæ˜¯å¦æ˜¾ç¤ºé€‰æ‹©è¾“å‡ºç›®å½•æŒ‰é’®
            const supportDirPicker = 'showDirectoryPicker' in window;

            if (supportDirPicker) {
                els.outputBtn.style.display = 'block';
                if (state.outputHandle) {
                    els.outputInfo.textContent = `è¾“å‡ºç›®å½•: ${state.outputHandle.name}`;
                } else {
                    els.outputInfo.textContent = 'é»˜è®¤ä¿å­˜ä½ç½®ï¼šDownloads (å¯ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®ä¿®æ”¹)';
                }
            } else {
                els.outputBtn.style.display = 'none';
                els.outputInfo.textContent = 'ä¿å­˜ä½ç½®ï¼šæµè§ˆå™¨é»˜è®¤ Downloads (ç³»ç»Ÿé™åˆ¶æ— æ³•ä¿®æ”¹)';
            }

            els.downloadBtn.style.display = 'none';
            els.saveBtn.textContent = 'ä¿å­˜å¹¶ä¸‹ä¸€å¼  (S)';
        }

        // åŠ è½½å•ä¸ªæ–‡ä»¶ (æ”¯æŒ Handle æˆ– File)
        async function loadSingleFile(fileOrHandle) {
            state.isSingleFileMode = true;
            state.files = [{
                name: fileOrHandle.name,
                handle: fileOrHandle // å¯èƒ½æ˜¯ File å¯¹è±¡æˆ– FileSystemFileHandle
            }];
            state.currentIndex = 0;
            state.currentFileName = fileOrHandle.name;
            updateFilenameDisplay();

            // æ›´æ–° UI
            els.downloadBtn.style.display = 'block';
            els.saveBtn.textContent = 'ä¿å­˜ (S)';
            els.outputInfo.textContent = 'å•æ–‡ä»¶æ¨¡å¼ï¼šä¿å­˜åˆ° Downloads';

            els.fileList.innerHTML = '';
            const li = document.createElement('li');
            li.textContent = fileOrHandle.name;
            li.classList.add('active');
            els.fileList.appendChild(li);
            els.fileCount.textContent = 'å•æ–‡ä»¶æ¨¡å¼';

            // è¯»å–
            await loadFileContent(fileOrHandle);

            // é‡ç½®é€‰æ¡†
            if (!els.persistChk.checked) {
                resetWatermark();
            }
            updateWatermarkStatus();
            initCropRect();
            render();
        }

        // ç»Ÿä¸€è¯»å–æ–‡ä»¶å†…å®¹
        async function loadFileContent(fileOrHandle) {
            let file;
            if (fileOrHandle.getFile) {
                // API Handle
                file = await fileOrHandle.getFile();
            } else {
                // Standard File object
                file = fileOrHandle;
            }
            const bmp = await createImageBitmap(file);
            state.currentImage = bmp;
        }


        function resetWatermark() {
            state.watermarkRect = null;
        }

        async function loadFileList() {
            state.files = [];
            els.fileList.innerHTML = '';

            const isApiMode = state.inputHandle && !Array.isArray(state.inputHandle);

            if (isApiMode) {
                // API æ¨¡å¼: éå† DirectoryHandle
                for await (const entry of state.inputHandle.values()) {
                    if (entry.kind === 'file' && /\.(jpg|jpeg|png|webp)$/i.test(entry.name)) {
                        state.files.push({ name: entry.name, handle: entry });
                    }
                }
            } else {
                // å›é€€æ¨¡å¼: state.inputHandle æ˜¯ File æ•°ç»„
                state.files = state.inputHandle
                    .filter(f => /\.(jpg|jpeg|png|webp)$/i.test(f.name))
                    .map(f => ({ name: f.name, handle: f }));
            }

            // æ’åº
            state.files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

            // æ¸²æŸ“åˆ—è¡¨
            state.files.forEach((f, i) => {
                const li = document.createElement('li');
                li.textContent = f.name;
                li.className = 'p-2 text-xs rounded cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-700 truncate text-slate-600 dark:text-slate-300 transition-colors';
                li.onclick = () => loadFile(i);
                els.fileList.appendChild(li);
            });

            els.fileCount.textContent = `${state.files.length} å¼ å›¾ç‰‡`;
            if (state.files.length > 0) loadFile(0);
        }

        async function loadFile(index) {
            if (index < 0 || index >= state.files.length) return;

            // UI æ›´æ–°
            const items = els.fileList.children;
            if (state.currentIndex >= 0 && items[state.currentIndex]) {
                const prev = items[state.currentIndex];
                prev.classList.remove('bg-blue-600', 'text-white');
                prev.classList.add('text-slate-600', 'dark:text-slate-300');
            }
            state.currentIndex = index;
            const current = items[index];
            current.classList.remove('text-slate-600', 'dark:text-slate-300');
            current.classList.add('bg-blue-600', 'text-white');
            current.scrollIntoView({ block: 'nearest' });

            state.currentFileName = state.files[index].name;
            updateFilenameDisplay();

            // è¯»å–æ–‡ä»¶
            await loadFileContent(state.files[index].handle);

            // é®ç½©å¤„ç†
            if (!els.persistChk.checked) {
                resetWatermark();
            }
            updateWatermarkStatus();

            // åˆå§‹åŒ–è£å‰ªæ¡†
            initCropRect();

            render();
        }

        function initCropRect() {
            if (!state.currentImage) return;
            const imgW = state.currentImage.width;
            const imgH = state.currentImage.height;

            // ç›®æ ‡æ˜¯ 16:9
            // å¦‚æœæ˜¯è£å‰ªæ¨¡å¼ï¼Œåˆå§‹åŒ–ä¸€ä¸ªæœ€å¤§çš„ 16:9 æ¡†
            let targetW = imgW;
            let targetH = targetW * (9 / 16);
            if (targetH > imgH) {
                targetH = imgH;
                targetW = targetH * (16 / 9);
            }

            state.cropRect = {
                x: (imgW - targetW) / 2,
                y: (imgH - targetH) / 2,
                w: targetW,
                h: targetH
            };
        }

        // === 2. æ¸²æŸ“é€»è¾‘ ===

        // ç›‘å¬æ¨¡å¼åˆ‡æ¢
        els.radioModes.forEach(r => r.addEventListener('change', (e) => {
            state.mode = e.target.value;
            render();
        }));

        function render() {
            if (!state.currentImage) return;

            // 1. è®¾ç½®ç”»å¸ƒå°ºå¯¸
            // è¿™é‡Œçš„é€»è¾‘æ˜¯ï¼šMainCanvas å§‹ç»ˆä½œä¸º"æœ€ç»ˆè¾“å‡ºé¢„è§ˆ"
            // Pad æ¨¡å¼ä¸‹ï¼šMainCanvas æ˜¯ 16:9 çš„æ‰©å……å›¾
            // Crop æ¨¡å¼ä¸‹ï¼šMainCanvas æ˜¾ç¤ºåŸå›¾ï¼Œç”¨ InteractionLayer æ˜¾ç¤ºè£å‰ªæ¡†
            // ä¸ºäº†ç®€åŒ–ç»Ÿä¸€ï¼Œæˆ‘ä»¬åœ¨ MainCanvas ä¸Šæ€»æ˜¯ç»˜åˆ¶"æ‰€è§å³æ‰€å¾—"çš„ç»“æœä¸å¤ªå®¹æ˜“ï¼Œ
            // ç­–ç•¥ï¼šMainCanvas ç»˜åˆ¶åº•å›¾ï¼ˆåŸå›¾ï¼‰ï¼Œæˆ‘ä»¬åœ¨ä¿å­˜æ—¶å†åšçœŸæ­£çš„è£åˆ‡/å¡«å……ã€‚
            // åªæœ‰è¿™æ ·ï¼Œå»æ°´å°çš„ç¬”åˆ·åæ ‡æ‰èƒ½ç»Ÿä¸€å¯¹åº”åˆ°åŸå›¾ä¸Šã€‚

            const img = state.currentImage;
            els.mainCanvas.width = img.width;
            els.mainCanvas.height = img.height;
            els.layerCanvas.width = img.width;
            els.layerCanvas.height = img.height;

            // ç»˜åˆ¶åŸå›¾
            els.ctxMain.drawImage(img, 0, 0);

            // 2. åº”ç”¨å»æ°´å° (ç®€å•çš„å‘¨å›´å¡«å……ç®—æ³•)
            applyInpainting();

            // 3. ç»˜åˆ¶äº¤äº’å±‚ (è£å‰ªæ¡†)
            drawOverlay();
        }

        function applyInpainting() {
            // è±å½¢æ¸å˜å¡«å……ï¼šä»è±å½¢è¾¹ç¼˜é‡‡æ ·ï¼Œä½¿ç”¨åŒçº¿æ€§æ’å€¼æ¸å˜å¡«å……è±å½¢åŒºåŸŸ
            if (!state.watermarkRect) return;

            const ctx = els.ctxMain;
            const imgW = els.mainCanvas.width;
            const imgH = els.mainCanvas.height;

            // è¿˜åŸæ°´å°æ¡†åæ ‡ï¼ˆå½’ä¸€åŒ– -> åƒç´ ï¼‰
            const rect = {
                x: Math.floor(state.watermarkRect.x * imgW),
                y: Math.floor(state.watermarkRect.y * imgH),
                w: Math.floor(state.watermarkRect.w * imgW),
                h: Math.floor(state.watermarkRect.h * imgH)
            };

            // è¾¹ç•Œæ£€æŸ¥
            if (rect.w <= 0 || rect.h <= 0) return;
            if (rect.x < 0 || rect.y < 0 || rect.x + rect.w > imgW || rect.y + rect.h > imgH) return;

            // è±å½¢ä¸­å¿ƒå’ŒåŠå¾„
            const cx = rect.x + rect.w / 2;
            const cy = rect.y + rect.h / 2;
            const rx = rect.w / 2; // æ°´å¹³åŠå¾„
            const ry = rect.h / 2; // å‚ç›´åŠå¾„

            // é‡‡æ ·è¾¹è·ï¼ˆå‘å¤–æ‰©å±•é‡‡æ ·ï¼‰
            const margin = 5;

            // åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨è±å½¢å†…
            function isInsideDiamond(px, py) {
                const dx = Math.abs(px - cx) / rx;
                const dy = Math.abs(py - cy) / ry;
                return (dx + dy) <= 1.0;
            }

            // ä»è±å½¢å››ä¸ªé¡¶ç‚¹å¤–ä¾§é‡‡æ ·é¢œè‰²
            function sampleDiamondVertexColor(vertex, offsetX, offsetY) {
                const sx = Math.max(0, Math.min(imgW - 1, Math.floor(vertex.x + offsetX)));
                const sy = Math.max(0, Math.min(imgH - 1, Math.floor(vertex.y + offsetY)));
                const pixel = ctx.getImageData(sx, sy, 1, 1).data;
                return { r: pixel[0], g: pixel[1], b: pixel[2] };
            }

            // è±å½¢å››ä¸ªé¡¶ç‚¹
            const topVertex = { x: cx, y: rect.y };
            const bottomVertex = { x: cx, y: rect.y + rect.h };
            const leftVertex = { x: rect.x, y: cy };
            const rightVertex = { x: rect.x + rect.w, y: cy };

            // ä»é¡¶ç‚¹å¤–ä¾§é‡‡æ ·é¢œè‰²
            const topColor = sampleDiamondVertexColor(topVertex, 0, -margin);
            const bottomColor = sampleDiamondVertexColor(bottomVertex, 0, margin);
            const leftColor = sampleDiamondVertexColor(leftVertex, -margin, 0);
            const rightColor = sampleDiamondVertexColor(rightVertex, margin, 0);

            // ä½¿ç”¨ ImageData è¿›è¡Œé«˜æ•ˆåƒç´ æ“ä½œ
            const imageData = ctx.getImageData(rect.x, rect.y, rect.w, rect.h);
            const data = imageData.data;

            // æ¸å˜å¡«å……è±å½¢åŒºåŸŸ
            for (let py = 0; py < rect.h; py++) {
                for (let px = 0; px < rect.w; px++) {
                    const absX = rect.x + px;
                    const absY = rect.y + py;

                    // åªå¡«å……è±å½¢å†…éƒ¨çš„åƒç´ 
                    if (!isInsideDiamond(absX, absY)) continue;

                    // è®¡ç®—ç›¸å¯¹äºè±å½¢ä¸­å¿ƒçš„å½’ä¸€åŒ–ä½ç½®
                    const tx = rx > 0 ? (px - rx) / rx : 0; // -1 åˆ° 1
                    const ty = ry > 0 ? (py - ry) / ry : 0; // -1 åˆ° 1

                    // åŸºäºä½ç½®ï¼Œè®¡ç®—å››ä¸ªé¡¶ç‚¹é¢œè‰²çš„æƒé‡
                    // ä¸Š/ä¸‹æƒé‡
                    const topWeight = Math.max(0, -ty);
                    const bottomWeight = Math.max(0, ty);
                    // å·¦/å³æƒé‡
                    const leftWeight = Math.max(0, -tx);
                    const rightWeight = Math.max(0, tx);

                    // å½’ä¸€åŒ–æƒé‡
                    let totalWeight = topWeight + bottomWeight + leftWeight + rightWeight;
                    if (totalWeight === 0) totalWeight = 1;

                    // åŠ æƒæ··åˆé¢œè‰²
                    const finalR = (topColor.r * topWeight + bottomColor.r * bottomWeight +
                        leftColor.r * leftWeight + rightColor.r * rightWeight) / totalWeight;
                    const finalG = (topColor.g * topWeight + bottomColor.g * bottomWeight +
                        leftColor.g * leftWeight + rightColor.g * rightWeight) / totalWeight;
                    const finalB = (topColor.b * topWeight + bottomColor.b * bottomWeight +
                        leftColor.b * leftWeight + rightColor.b * rightWeight) / totalWeight;

                    // æ·»åŠ å¾®å°å™ªç‚¹æ¨¡æ‹Ÿè‡ªç„¶çº¹ç†
                    const noise = (Math.random() - 0.5) * 4;

                    const idx = (py * rect.w + px) * 4;
                    data[idx] = Math.max(0, Math.min(255, Math.round(finalR + noise)));
                    data[idx + 1] = Math.max(0, Math.min(255, Math.round(finalG + noise)));
                    data[idx + 2] = Math.max(0, Math.min(255, Math.round(finalB + noise)));
                }
            }

            ctx.putImageData(imageData, rect.x, rect.y);
        }

        // === Gemini Watermark Removal (Reverse Alpha Blending) ===

        // Pre-captured watermark alpha maps (inline base64)
        const geminiWatermark = {
            alphaMaps: {},
            bg48: null,
            bg96: null,
            initialized: false,
            // Base64 encoded watermark capture images
            BG_48_BASE64: 'data:image/png;base64,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',
            BG_96_BASE64: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAfrElEQVR4nJV9zXNc15Xf75zXIuBUjG45M7GyEahFTMhVMUEvhmQqGYJeRPTG1mokbUL5v5rsaM/CkjdDr4b2RqCnKga9iIHJwqCyMCgvbG/ibparBGjwzpnF+bjnvm7Q9isU2Hj93r3nno/f+bgfJOaZqg4EJfglSkSXMtLAKkRETKqqRMM4jmC1Z5hZVZEXEylUiYgAISKBf8sgiKoqDayqIkJEKBeRArh9++7BwcHn558/+8XRz//30cDDOI7WCxGBCYCIZL9EpKoKEKCqzFzpr09aCzZAb628DjAAggBin5UEBCPfuxcRiIpIG2+On8TuZ9Ot9eg+Pxt9+TkIIDBZL9lU/yLv7Czeeeedra2txWLxzv948KXtL9WxGWuS1HzRvlKAFDpKtm8yGMfRPmc7diVtRcA+8GEYGqMBEDEgIpcABKqkSiIMgYoIKQjCIACqojpmQ+v8IrUuRyVJ9pk2qY7Gpon0AIAAJoG+8Z/eaGQp9vb2UloCFRWI6igQJQWEmGbeCBGI7DMpjFpmBhPPBh/zbAATRCEKZSgn2UzEpGyM1iZCKEhBopzq54IiqGqaWw5VtXAkBl9V3dlUpG2iMD7Yncpcex7eIO/tfb3IDbu7u9kaFTv2Xpi1kMUAmJi5ERDWnZprJm/jomCohjJOlAsFATjJVcIwzFgZzNmKqIg29VNVIiW2RkLD1fGo2hoRQYhBAInAmBW/Z0SD9y9KCmJ9663dVB8o3n77bSJ7HUQ08EBEzMxGFyuxjyqErwLDt1FDpUzfBU6n2w6JYnRlrCCljpXMDFUEv9jZFhDoRAYo8jDwMBiVYcwAYI0Y7xuOAvW3KS0zM7NB5jAMwdPR/jSx77755ny+qGqytbV1/fr11Oscnph+a1PDqphErjnGqqp0eYfKlc1mIz4WdStxDWJms8+0IITdyeWoY2sXgHFalQBiEClctswOBETqPlEASXAdxzGG5L7JsA/A/q1bQDEkAoAbN27kDbN6/1FVHSFjNyS3LKLmW1nVbd9NHsRwxBCoYaKqmpyUREl65IYzKDmaVo1iO0aEccHeGUdXnIo4CB+cdpfmrfHA5eVlEXvzdNd3dxtF4V/39/cFKujIJSIaWMmdReqFjGO2ZpaCUGRXc1COvIIOhbNL3acCQDb2Es5YtIIBI3SUgZw7Ah1VBKpQmH0RlCAQ81noVd16UnKMpOBa93twRbvx9t5ivnC1MQ4Rwaxsd7eyu36wUQzkxDMxmd9Rl6uxyaU+du6/sEBERkMrUmSgY97DyGN7pwlc4UqUuq1q0Cgi6LlrHtY0yNQnv5qMZ/23iHexf/OmhXr5ajZycHC/oklqsT1BAYK1lxy/RtCUNphW0uDCZUdJP3UBCgAwmEYVoiEBmyBEauFJ0w4JnGdWSvCHJHK5TimY3BW5hUqNnoxpNkYiWuzM927sdWakjUfXd3cX83mMzBVcRaAGgo0wOA5YvGZdiMjo5sZEA4NLMK2SKAZpumZDViWMgBjgFoHXq0p7YpberAgA5iC0iMgF7r4fKX/nZDSmqvfu3attrne0f+tWCsmxdhhSlao/yp5SkZkpoj6dtN/rshANptFVfZgtsHAJSKYmREqkDNWxSYM5GjWvpIAoGIJIgkR1lPBrEQCqQiwzM91G+ACGYLHz+q39W5UlTkC5c/f2nWvXrjnQBLKk3WlkdqRQESIGKPwdjxp4Fw4XmaVYKKUQqKE+GEqw4COIIZHwYqkpqtpsLeJOs50ItFpgYoJJL1Dl74lEoobLChbqARiGYX9/XzHV3OzU/tza2rp7925VE44rlcJlTi2VqcplXWeQMfVTmg63Cak+UIIXVQXzbHAzjywnHhsQTtSkoapE3GJiu6Tpp/VYs1PjkcHBl+c7+/v7BKoaQ2SOCCDNb27fuX1t65qJmgYWBIIw0eDphRJM8lr426ROMABSQs3FwAB5EDMMM+ZZlXc+gprFQDnMm2salYFGdQEosU+2aFmuMdX+ybdM8kb3/YP788WihUONJiViTVgnbG9/6c7du0Q0ljCKIoJvFBY3VEU2USuQELdMkJhNhKZiGmlTY5CZTyZyImLGLlBNpRUikKmRB2/mHUM7Mj50iYWXcUMI6YmKBX47Ozs3b36jKg4oYgKFNUupWap3bt+Z7+xYDigiSiygcRyppNkM0lHM1ZICMjJUVCz4NtlbVcfZqgohHaEQwUgtlyoYJ9KKT6lKIpLp/LpbMV3wBKIm0OKZoaq/raOM/3qJgkQUEj44OLCRh4ynvjLU2f/c3tp68OBBakcx2FYkMDmJiNmIB3PULjT1j7ciQKnxXQ2UeBgYUHMzAEQvFSNYlYQwQFrEGVA1dE2IQERMAgMEYjCRDzPPKmX2+e0be/vfuBkKktgIoqaGwbMmmL29vTff3I1xewUqC0Cq5nOK6TFqrquqyqoOUi11hPnZsUV8FLHiQAxRRoG0asNExMNg+XdVv57TbQAWR4hLz6Dh0kJEVU0LB/BO6MJEObuakY2td3Hvfvfd7e1t6omMyAUAtBaOyxUm1hHfY5NbwBClC2Sg51qmYJANzx2JjtAxogZk7uspj3PNQx6DYCJmmmkEqESkKqZlKfaDeweL+VxrvFwGktwBoAnU4c4W88X9gwNS8TqBR+3+UGW4KQcR7GGyorcIhyKnETAzgxkDqZKKoZiqZNbUkm/K8K5wfRIUVAiotfcUiKpSqwB6Vqnq6PPVr3713r17zfLXL+rvR9ICdSC/ffvO7u51J52b+mdklLDNnNoRH/q6lUZoHmQjm2UmzUpGhElehIZ0fHE8F4XoQDOGFRXJ80e28iKrEmGQEYl/RMqzGZhFHC/mX955/72/s8jMR7+RR21U8bV9DA159913t7f/HdEAZVI2s4o40Avno14Gs9j9aY1CGth7nsjMEX+LYIQQKUcVqahAKkhyN0EhYajoUfMpLWpwf+/Ba7mDg4OD+c7CzCgUr5MwjCkGF9IqCl0pjTBfLL77ne8YiQ0uu8C6hdfVRWRMv24Wlo4F9Gg+Q0RliqMRMdjT1fWYfKxCmDcBj1kAWADmwAYmZfMCYFXC3x7cu7l/s3aSvxQgTutWr5umi4sPYWoAsHdj787f3CZS1bFiykAzCBGxjKo0jIFKqqPIZdR61GZZmBkggM39JdYyD9mmiLAqVDDhKFFXh88Xwr6iqoQWQVRWpg4CgOj169cP7h1URdCsKJKDVGOcexxMwoCJur3zzjtvvvlmEWpTZx3B/BplfBQSjVG0cC+RyzNEbSqGzPtIiSnQziom7AVgcJ+2mYoSaPAqTxbx3PGJVtS3Mtt8/vr7f/felWijUFFMHFpGiRWzC2Db9f7777/++rwW5y/FFEqho1uHKBMDnGhrHj39jE8ujqqqIMdsq4VZENfGU6UBQGS0e7XMXJ9J866/VTNphkB3dnYePny4tbVV360aMf1btUEzrX3f5+vb29sPH364mM9TZw1rndpWq3HK1wsAOQoeuijRO7Q2lUSQDlut7mPqbNZYp5KJyGZfqjVx5Htl1ghgnr8+//B7Hy4WiylrvK3yO3lAoLCyyENexdT54vXvffi9+Zd3krzWPCmjhoJUw+6cNVNVUlYlJcEwad7wNN8n8vpGIr/VSqg9AAf5Rk1KI8DbMkVsb29/+DC4c7U77741gK55WSIRNXY2ZbTocbH44IMPtra2mNnTV3fBha/FRyNYv0mp1+4ARAOriAXDSqIK5kEtrFQwD5k0O/sJsNS5xARtxYUCTPPXd95/7/2v/sc3oo/SNSHgxP5qk/QETy+d1sI4f4DQyiB5RwFguVz94B9+sFwumVkuPd2hCBpVRxXYDGiUotlm7pQ8MRAoiAY0F6SjqcXANjBVtaUtEQwrs8fvlgTGMwT48pc6Z5D8ev311x9++HA+n1OIpDGIHEpy6M6g6uJTa6x8BlKrqCO8WyffxrXVavXo0aPVapVZVap/zBrYSNtnJWmCV62fAZByA+nIGxiIUiBskYy7ZGtLCb5GoiS3KOoa3FkAJXGpHrrVEBUTPbcgsY83jF+K9dpspmz+13w+//Dhhzs7O4YGCYh1MqrhdLzV1i6VycUasvgaEcN80ybEjBUNHDBkDnxQ7bhjgsolI2+99dZ77723tbUVaw7Mhf8lFxUdydBR+/trPKJ4CsD5+fnHH398dnZm34dTK1ojwp57kJJHaomzFafYqoLD7Jqqyviv5iOTQV3oSMX02yxeV/S8fef2tx98GxvB7y+6NvJigkf9Y+Ytar+Hh4eHP3uao1ARtnRd1Tz1RschyGURREQDzVSViGeqHllVDVJV046CTVZAaBUr++e1115799139/b2/oIB/5nf+3dmlpFuxFfUMwW9ChyfHB8+fbparXzsANEACKACxxq7HD3JEk57nckKzRRrEOr0rk+o2qPsXPeyb/gvr5Ardnd3v/Pud82dV/q6QeJP8GjKkfyNeHddg9Y4st77arX64ccf/f73v4cID1CBxMIdtizMWSMI7xzYxMmBzFAasqShWdBd4uP2GoBr167dPzi4fefOnzvsyajSneczsAC8Wk7vuSjuqm7UoI3COPzZ039+eig2HUDwWg+8dgxEEkIWqDqDEJ6deDYQKcTr8LGMzCbsWwJBRKphVord3d3vfue788V8M3HNbVOSEXyJxyYMqhxZG2TXxeSP3g9ufHH1cvlPT56cnp5G+JmFSDe9EqmIGVchakDeyuds2seZyTyOl4AHkPOdnQcPvr1344ZFfH0E6ExxRhRV8BrN1CG194nR0qwW9BbDqdwpZjjVIwoaqvYRYKj0yeHy5UvYmuVSFOw6goeOnq/Nrr3WKo9j1ZqWyAhGAFuvbd+9e/f2ndvb29ubHA2Zs82eJpy6Mthr/KXmrjc/ENyZ3J+E6Y2hrsDEbfAnJ8efHD5dLpdMM1UFCW2EToB8RqPN0rj9ZyUo37y2de3u3Tt3bt/1GOcV+l+tqR+AM+iqd5uou/rQn8GgK9halcsTDn9/uVwdnxwf//JfVqsVD6gFE9iyX26RdHPtlkZYSgHAErSdxfyb3/zm7dt/s7W1vWlkV4/zFWpy1firt9qoTVfx6CpyOvPsX1aAcHJ8cnh4uFqtmFnkkpkrr+CxDDvuGu6kHu2++ebBwf3d67vxKLDuNeqw1z3OVfHeK4Zn6sCEUcG2WGYtpvuL4tA1oytNOGT/6lenJycnn356CkDEc4OEFwJ7+AdAFbu71/f29m7d2u9UpoYnVw3sFXrRkRufuupUfEFrjVwdBF3ZC2LsiKrAelSl3TvM/Ic//OHs7Ozk5P+enZ3lYigzMWxtbb99Y+/69et7e3tXmhKV1oMEb4XNvF2DpgBUjSX5EP62Mah5/U2hzSsYtNFsJ8C0Rnx8pUmMmkmKrlarFy/Onj9//tvf/na5XNKd/3rnwTsPGgUdCnh+0cF87SZ1ta2gaBR2JE/AuwsCE8ZfwQWahpT55JW2TNMQqQ6qNexfhKQ6Mf/0pz/lO7dbKFwmgaxbLVyaEFy7105lJhFyzyqvJKxHwGVSrNKdXXR8mejZ5FnP4LXeL2sl2jYDiqmaYE0Tvjnxe/fuzba3m02VMnCIND53I6qmUc1nSjQBWise6WiNYi39IZEh6JtyhLLmuHZV9TRnIvF6amqngGZPhgzkAiZE+wbJpIrPzy/48OnTJpM1BEAKk6b369gmH6+6GXpBU4doItA11KgtaNPojV2o1yK5GW8PfOtXgE+17q7jo6NnRAN/5Stf+ev/8Fdf//rXd3enm0omUeYr/Nhffl0BORT68oqoEuXVDS5s7ZWNnNoI4UrnFxfPT391dnZ2enp6cXER6yBdD8fd3es3b+6/9dZb8/l8I+VY49qfc00z1Y6u9ac3RxUdmmn/cG1yveUJg7Sgftw8Pz8/Pjk+PX3+4uw3sdRHPZImanXZTMG+duNrt27t3/jaXhJxZbmno6/knzUXWwvSYClSK25c4Yw6gIdepcSb4G/DY5PnCQDOzl4cPj08++zXICLL46XlsV6Trjuw/GJV1fmXF/fv379586bfs2nDnBhZj32ok0/mX5EuUoQejJgNmPJi3aP/ycG/ysSom0FC082Li4ufPzs6OTlZLpeAwFKuEcaNnA0lWxgdjQ0gYZBqrIwQArCzmO/v79+6ub9YLCpTYOFPDuwqkitY2AjDH13hl4IxtBbLKCZhgze6ITQl0HqmQoCen58/Ozo6Ojq6uDi3u5ZmCSmJTe359AQREc+GtqJFGSQQJfKikk2ejSrMvPPvv3z//v2b+zfTrVYoVcvjwoF0SlyVCx3FmxiU4fb6yHsG1cFr90wPN63li4vznx/9/Ojo6PKLL2SSmDIJKSuRwnbrkA9zKLPPZWrQ9gXaQit7wOrQO/Odb33rW9/4L9+oGjSpARGzqnS2UEOVdW5sMCKsffEnUKWZ/BXX6enzJz958vLlS1X1FQheWeS0GFtCZ3X3WIo5+KKY5stiupaI6opMz3GZANz4z1978ODBYrFoeUKfgmX9xW+/gkEbsXnCkbU7V3iM4v+K7qxWy398/Pizz36TrwwE9X3ABoheurcimRtXaJBnEiWf4GSQ1Wvd58XmGYQ23bt3r+1n2ui101w2lUr6Ofu+KDEpg1IkhH0jU/ZuigmPnh09fXp4fn6eKzU2XsoKUQjIdkBlyZVn4c/iVkxoxzrNXL9xOdb5eHvrjTfe+OCDDyp4b2SQm6F/bgtLu2pHA/5N0L0mgA0S6Rm0XC4f//jxixdnceNKBhGR2L567eaWYRoEoJ/0aK95Md+wRpQAHmw7kACggSG6WCwODg5u7u9vcM9XaRCF9+3jvaicYN15rcfWVzDIGz09ff74x48vLi4A9FseNzNLWZNB1KHqAIqDSMLq6mDK/pmOr6Q2ly+qqsMw/Le//e8H9w4azYRalNow9+AimUxaxCsVa9KR2/Kq0Pe4vcYz4MmTJ89+8YtCrU4MPKew2h0SU6QEk4yk850oWnmtk0EEjHmmi/VRS/q5CMaM8vr16++/957PeRBitdhVCzNcI7qAux+nZ4/UsQxTEXZQdH5+/tGPPn7x4oWq5GxwQQ+NhWXJoDjxhe2Ui6G0HBPWRCTSlpo7BCkTs+olgG4e0rkZGsfJaVLVxWLx8H8+XMznyEmFcCydEoW+ELKy8cqSGLCBy0hccxnYEqHly1UObxPuCMfydj91Bc2LDTSrs/CqI2EGYFMtmOx+S2VhSUZZ4u9QLQS2A1QEwM7O3BffrYWF6YIzBdkQ2uGK53WNWzViUl2ulo++/2i5XKLUQNOOTIQiYqbEakstxRb2JINIbXkU5wrGXGmPbAgZJdcVMOl3y0Ly/M3lWJ9VEkrTMJ84Qu0WW1MutfBV7dO3+ue7y5RTAf3d73//6PuPVqsl+c4aSiKnjdTRZgUvky3/t+zUj09TmjBFNcc5W31suyL8RCHKw3B8N81yufz7//X3v/vd79aGWWq36zqbVW2DHu0fs5ps7GktjdByufqHH/zgjy//qLEsNVdC2+4dKqXV2oCtb23jL1LPq+UZlUrPRAqDc7N0ZVY04SqtfpKJEuHi4vyjH320XC2nbGj+qTXXfdW7+ahBxsq9CMqT0cvl8tH3H33++YWI5BkYuTbQ9rvVrQGq+SFsIltTtYAmFwnDViSWJasEMCnn+o/c/7O+oc46U4UgVGno9GK1XD569Gi5XPYimVgdHGK1vFt4qCV8d0ii6JuwXK3MnAVj2TuWg9dRR49gYhE086BKNVMloE1Lw/fca9jWZJ10YAqocrrpZ2RYkQAUi7EZ2u78L1qtlo8ePfr88/PKlLoDeO3qgc9/ty4pC+SE8/PzR99/9PLly/SheS5FwWYQkc2419XubaRxpd1pH0O0fQwASGEnvqgqg9HtAnEzti0yOQoiUoIyUZyhkZdt0lwtlx9/9BEZpqjz28ZNayq5XpmncFXFLJxzH/3wRy9Xf6y8HmjI0AwA0WDrEicupfQ2ilzqeGknGZF6WFwpKkd0qdoJQxOZNlQKh1/QqY1wcpiGxoJGIrx4cfbkyZP1Nifkls/Ni657Hvv+8PDwsxcv1llsM+vWRJtij73y651edeUzTCozbh5RMAqUZ4PtpFcdY3NGxKDEqcLKUKaBZmzbHdqPeZA2tl8cPXt+ejrhjmqBmG5uVpsfy3XVoYBQHP/yl08PnyLO74PFYoCq2lqvcpnDFekPb/SKDw2qJJ1c/SQT1VFVBlsK3JxixIe2/WCC9iJQ6jCrEqL98QLsx9IN7tmZ/vHx4+VyOZGSa3QN+Vro539NnOZqtfrZz35GsRLOVDt3E0a/1K3QoC4di3NrbPd4t0esrSVXEEFE2OM7AdFA4ExG1NYMeZ1ogLRtjxZIqCorsfp+USJqG/YNgFiVxM4bEugXX3zx+PHjwh7TIMkAoxO8OlxXL2aG98OPP1q+XNnhlVHbU8VIZPu8eojlmalJ4qwL2z2vY/BAea7MyGz5w8DMEWUrQCSxtb1qR9TSNFfJUnDHuCCSu+3HtSCgk7wSPvvss2fPnrW/C+iU9xqUhsdsPvjw6WGNP3PxYI58EkOPl7a6su2P7i9XpWyHSlo7jgrf9MJ22EoXCnpQBLYzUbrWc9QM2DlDMqqVckQYHnl5A/aGuK89PDy06JGyJOQA07kYNbCpnRKtVsunh/88EA/E0QsZPtr+2BybBXuqo51t1vsZCtJtpKNvs40f5pkveGYCD75OkcrG4Xq5JKk75mEiCe9U1SBIPaPoQIqIbLnkxcXF4x//GBQ1HXRtBkpXvrTf//Tkie10HscxZ2JUDZvrTrHkVAviaqSS4p1koFouS/dlHNk2/ChBMJop+k876ETJjpKFxQm2J3qwmDsxi5RFkpUAQCqx9wgqlyFJefHrs+enzwGN0zO7ALlX0XYdnxx/+umnNEQXwyw5q6o0wE5wycsLOHYOCakhDhHleYl+PlnQ7D9gUX/G9rt2WpMMrla9LoHq3aoEXC6bAmWeDRqbEYnoyZMn5+clvHY3EcoySU0IAA4/+aSBURwYpKWGV0liP/CttNLTHF4vM7/UJQGVPd0A2zG/REqkdi6inT4QN4nIj5AzjTBtyvOk1eq4QhAdiAEWOy3DXBwx+dFhY+44U8Ly5erZs6OOhZG71KSMfFETjk9OVqs/QuPssHIsj/q2d/LN3d6bbXGiyBNINY7osfMa1N8gZtsCh/YT3AQrnNNpqE2iVV9SPnX/Uy1RZ0K/rlP+LkesF/WaOvNL7Jm69vhj7S2Xq6dPn5psiwV1dfjCL53NZgapWYGwr7rTZXoie4WX2jjXpzUOJwzAUyUZ9dJ0x2S1TpOI5L4FirMw86AuWPBZKl7G988vzn9+dGQG1ZG9hkLHx79cLv+/siprFKFaO86XEYhzPBKnS17aVMPxxVro9mQ0r+L+SkeCdBhERDU7GwbWmKrLYwZrpBCPDQlSE1fIE9nUkA84enbUIdHkCh6d/Mux1vSvBPf5mW2XUwQ1Odqr9LoqeK24Z+SVLbTxiHSFIiWMowBkx1dmKXNUyd0L1p4hgB/22icc4eDayKwr1ZGBL87PjwyJJl6rGNrxyfFqtWImUmYvALIhZh9JiOrY7acFkba9uDl7wxgMNEnZbFbgAbMQyI9pkIx789gYSz1aME7M5Afx+AL9DZYfR12lrDJCSe5svPKb4+NjoAt2Jn8eHh5WfcmcK1WDqK3+Sl02SiZHLayTRJlzAwrGpm85lMrYDFX4nP5ovPAT4jTP/kIjCAZAZZ6kqnRV2u6ID3CcKc4vly9fnL3oyon+Mgg4PT19+XIVMS6SNZE65MYJrsgdWqyqY0bYSR5EGWTxkZNqft1nt9rJs65B9kdh9rQqmNdEbtXOq21TXwN2ppe0oz4J4JNPPuk1p0XVx8fH6TRblWf0//7AQJB51o7RXkvNxnL8Y3XKG7V7ctOMI3IQ0ZhBHcAzRVffWX/Z74jmUXTrWFjY5xFtHMLWziFSwovffHZ+cR4ZmbMGhOVydfr/Ts1DEClIBaPIZZFfqFU4xzykzjggInZOq/HOUQk6qV4nUJLC4MlwygWAUB8ugOLlPO6CgGwxFSo9yEQyhcrW/bpw0iKOT46zn+AQXrx4kTcA+LKuiVeMRLQ5nYghM5LOqvNGEebYs5HJk8FysjMiRxHBCBKCHUQIAH7y+ERFs3UpR20nFjYbDIBnxH9+ArZKQtJ6evo8JZpx0Mnx/4Hk+fmceUGG4wz1gmHQlrGPqsLOktI4KiKQiJllHHWU/CFVHS8l0heL4DJA4RSy/VscZ5V2A51kSnLBGjUFro4jPgAS/jGqSxM3d3Z2dn5+UaeqV6vl2dlZfdi/KuR5Hk1NHimk6jqqXsOKpakvDg5O8ETq4cVKZEl21LglbDqa9O0ANCOl7vSdzWZZu0SEHhmJ+JKPPINXAIniKwXeNBPW0+e/qkHlr399FosuOs/o+Q3Zrv8WYRANFHBhg7RgbRgGK/INQwisnAOJQC6jqtkBtUUZXcmiqFLnsCYHu6U2orr52NTpZxFwpyP5n3mkVKuSEuHs12f1zumnz52zExQzhBRHfrMA0qYmteWkTbU7T7o9Foe4V12bqN5MR2Do4y772ghXVgiYRUfyVRCggWNWgDRiVq0g2tkp217+MtfsJ+ygDOn09LQG0L/77W+pLSrxBIIpAMGgnAReEgUgtovFqLLsUMNSfAkCQ3IFK1GS6px3LhtIj83iiHydXWVt8wHBzDijwqcE8j9eco+WI1ZLm6zM7RP2Whxfrzit34svzn/ykyfLPyzPz8+f/OTJ6uVLNLrF9qsbd2owXSWan6U73q47YXrioeqVEF4fBvBvwZvfB2giLLAAAAAASUVORK5CYII='
        };

        // Load watermark assets from base64
        async function initGeminiWatermark() {
            if (geminiWatermark.initialized) return true;

            try {
                const [bg48, bg96] = await Promise.all([
                    loadImageAsync(geminiWatermark.BG_48_BASE64),
                    loadImageAsync(geminiWatermark.BG_96_BASE64)
                ]);
                geminiWatermark.bg48 = bg48;
                geminiWatermark.bg96 = bg96;
                geminiWatermark.initialized = true;
                return true;
            } catch (err) {
                console.error('Failed to load Gemini watermark assets:', err);
                return false;
            }
        }

        function loadImageAsync(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        // Calculate alpha map from pre-captured watermark background
        function calculateAlphaMap(bgImage, size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bgImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, size, size);
            const { data } = imageData;

            const alphaMap = new Float32Array(size * size);
            for (let i = 0; i < alphaMap.length; i++) {
                const idx = i * 4;
                const maxChannel = Math.max(data[idx], data[idx + 1], data[idx + 2]);
                alphaMap[i] = maxChannel / 255.0;
            }
            return alphaMap;
        }

        // Detect watermark config based on image dimensions
        function detectWatermarkConfig(imageWidth, imageHeight) {
            if (imageWidth > 1024 && imageHeight > 1024) {
                return { logoSize: 96, marginRight: 64, marginBottom: 64 };
            } else {
                return { logoSize: 48, marginRight: 32, marginBottom: 32 };
            }
        }

        // Calculate watermark position
        function calculateWatermarkPosition(imageWidth, imageHeight, config) {
            const { logoSize, marginRight, marginBottom } = config;
            return {
                x: imageWidth - marginRight - logoSize,
                y: imageHeight - marginBottom - logoSize,
                width: logoSize,
                height: logoSize
            };
        }

        // Remove watermark using reverse alpha blending
        function removeGeminiWatermarkFromImageData(imageData, alphaMap, position) {
            const { x, y, width, height } = position;
            const ALPHA_THRESHOLD = 0.002;
            const MAX_ALPHA = 0.99;
            const LOGO_VALUE = 255;

            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const imgIdx = ((y + row) * imageData.width + (x + col)) * 4;
                    const alphaIdx = row * width + col;
                    let alpha = alphaMap[alphaIdx];

                    if (alpha < ALPHA_THRESHOLD) continue;

                    alpha = Math.min(alpha, MAX_ALPHA);
                    const oneMinusAlpha = 1.0 - alpha;

                    for (let c = 0; c < 3; c++) {
                        const watermarked = imageData.data[imgIdx + c];
                        const original = (watermarked - alpha * LOGO_VALUE) / oneMinusAlpha;
                        imageData.data[imgIdx + c] = Math.max(0, Math.min(255, Math.round(original)));
                    }
                }
            }
        }

        // Get or calculate alpha map for given size
        function getAlphaMap(size) {
            if (geminiWatermark.alphaMaps[size]) {
                return geminiWatermark.alphaMaps[size];
            }
            const bgImage = size === 48 ? geminiWatermark.bg48 : geminiWatermark.bg96;
            const alphaMap = calculateAlphaMap(bgImage, size);
            geminiWatermark.alphaMaps[size] = alphaMap;
            return alphaMap;
        }

        // Main function: Apply Gemini watermark removal
        async function applyGeminiWatermarkRemoval() {
            if (!state.currentImage) {
                showToast('è¯·å…ˆåŠ è½½å›¾ç‰‡');
                return;
            }

            // Show status
            els.geminiWatermarkStatus.classList.remove('hidden');
            els.geminiWatermarkStatus.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i> æ­£åœ¨åˆå§‹åŒ–...';

            // Initialize if needed
            if (!await initGeminiWatermark()) {
                els.geminiWatermarkStatus.innerHTML = '<span class="text-red-400">âŒ åŠ è½½æ°´å°èµ„æºå¤±è´¥</span>';
                return;
            }

            els.geminiWatermarkStatus.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i> æ­£åœ¨å¤„ç†...';

            // Get image dimensions from canvas
            const imgW = els.mainCanvas.width;
            const imgH = els.mainCanvas.height;

            // Detect watermark configuration
            const config = detectWatermarkConfig(imgW, imgH);
            const position = calculateWatermarkPosition(imgW, imgH, config);

            // Get alpha map
            const alphaMap = getAlphaMap(config.logoSize);

            // Get image data and apply removal
            const ctx = els.ctxMain;
            const imageData = ctx.getImageData(0, 0, imgW, imgH);
            removeGeminiWatermarkFromImageData(imageData, alphaMap, position);
            ctx.putImageData(imageData, 0, 0);

            // Update status
            els.geminiWatermarkStatus.innerHTML = `<span class="text-emerald-400">âœ“ æ°´å°å·²ç§»é™¤</span> <span class="text-slate-500">(${config.logoSize}Ã—${config.logoSize})</span>`;
            showToast(`Gemini æ°´å°å·²ç§»é™¤ (${config.logoSize}Ã—${config.logoSize})`);
        }

        // Button event handler
        els.geminiWatermarkBtn.onclick = applyGeminiWatermarkRemoval;

        function drawOverlay() {
            const ctx = els.ctxLayer;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // è£å‰ªæ¨¡å¼ä¸‹ç»˜åˆ¶é®ç½©
            if (state.mode === 'crop') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // æŒ–ç©ºé€‰ä¸­åŒºåŸŸ
                const { x, y, w, h } = state.cropRect;
                ctx.clearRect(x, y, w, h);

                // ç»˜åˆ¶è¾¹æ¡†
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                // ç»˜åˆ¶ä¸‰åˆ†çº¿ (è¾…åŠ©æ„å›¾)
                ctx.beginPath();
                ctx.moveTo(x + w / 3, y); ctx.lineTo(x + w / 3, y + h);
                ctx.moveTo(x + 2 * w / 3, y); ctx.lineTo(x + 2 * w / 3, y + h);
                ctx.moveTo(x, y + h / 3); ctx.lineTo(x + w, y + h / 3);
                ctx.moveTo(x, y + 2 * h / 3); ctx.lineTo(x + w, y + 2 * h / 3);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.stroke();
            } else {
                // Pad æ¨¡å¼ä¸‹ï¼Œæç¤ºæœ€ç»ˆèŒƒå›´ï¼ˆè™½ç„¶æ˜¯å…¨å›¾ï¼Œä½†ç»™ä¸ªè¾¹æ¡†æç¤ºï¼‰
                // Pad æ¨¡å¼å…¶å®ä¸éœ€è¦ overlayï¼Œé™¤éæˆ‘ä»¬æƒ³é¢„è§ˆå¡«å……åçš„æ•ˆæœ
                // ç®€å•èµ·è§ï¼ŒPad æ¨¡å¼ä¸æ˜¾ç¤ºç‰¹æ®Š Overlayï¼Œåªæ˜¾ç¤ºç¬”åˆ·
            }

            // ç»˜åˆ¶ç¬”åˆ·å…‰æ ‡ (å¦‚æœé¼ æ ‡åœ¨ç”»å¸ƒä¸Š)
            // (ç”± mousemove å¤„ç†)
        }


        // === 3. äº¤äº’é€»è¾‘ (å•æ¡†å»æ°´å° + è£å‰ª) ===

        // æ›´æ–°å»æ°´å°çŠ¶æ€æç¤º
        function updateWatermarkStatus() {
            if (!els.watermarkStatus) return;
            if (state.watermarkRect) {
                els.watermarkStatus.innerHTML = 'å½“å‰çŠ¶æ€ï¼š<span class="text-emerald-400 font-bold">âœ“ è±å½¢å»æ°´å°å·²å®Œæˆ</span>';
            } else {
                els.watermarkStatus.innerHTML = 'å½“å‰çŠ¶æ€ï¼š<span class="text-blue-400 font-bold">è¯·ç»˜åˆ¶è±å½¢</span>ï¼ˆæ¡†é€‰æ°´å°åŒºåŸŸï¼‰';
            }
        }

        // æ¸…é™¤é€‰æ¡†
        els.clearMaskBtn.onclick = () => {
            state.watermarkRect = null;
            updateWatermarkStatus();
            render();
        };

        // é¼ æ ‡äº‹ä»¶
        let isDraggingCrop = false;
        let lastMouse = { x: 0, y: 0 };
        let tempRect = null; // ä¸´æ—¶ç»˜åˆ¶çš„é€‰æ¡†

        els.layerCanvas.addEventListener('mousedown', (e) => {
            const rect = els.layerCanvas.getBoundingClientRect();
            const scaleX = els.layerCanvas.width / rect.width;
            const scaleY = els.layerCanvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            if (state.mode === 'crop') {
                // è£å‰ªæ¨¡å¼ï¼šæ‹–åŠ¨é€‰æ¡†
                if (mx >= state.cropRect.x && mx <= state.cropRect.x + state.cropRect.w &&
                    my >= state.cropRect.y && my <= state.cropRect.y + state.cropRect.h) {
                    isDraggingCrop = true;
                    lastMouse = { x: mx, y: my };
                }
            } else {
                // Pad æ¨¡å¼ï¼šå•æ¡†å»æ°´å°
                state.isDrawingRect = true;
                state.rectStart = { x: mx, y: my };
                tempRect = { x: mx, y: my, w: 0, h: 0 };
            }
        });

        els.layerCanvas.addEventListener('mousemove', (e) => {
            const rect = els.layerCanvas.getBoundingClientRect();
            const scaleX = els.layerCanvas.width / rect.width;
            const scaleY = els.layerCanvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            // é‡ç»˜äº¤äº’å±‚
            drawOverlay();
            const ctx = els.ctxLayer;

            if (state.mode === 'crop' && isDraggingCrop) {
                const dx = mx - lastMouse.x;
                const dy = my - lastMouse.y;
                state.cropRect.x += dx;
                state.cropRect.y += dy;

                // é™åˆ¶è¾¹ç•Œ
                const cw = els.layerCanvas.width;
                const ch = els.layerCanvas.height;
                if (state.cropRect.x < 0) state.cropRect.x = 0;
                if (state.cropRect.y < 0) state.cropRect.y = 0;
                if (state.cropRect.x + state.cropRect.w > cw) state.cropRect.x = cw - state.cropRect.w;
                if (state.cropRect.y + state.cropRect.h > ch) state.cropRect.y = ch - state.cropRect.h;
                lastMouse = { x: mx, y: my };
                drawOverlay();
            } else if (state.isDrawingRect && state.mode === 'pad') {
                // ç»˜åˆ¶ä¸´æ—¶é€‰æ¡†é¢„è§ˆ
                tempRect = {
                    x: Math.min(state.rectStart.x, mx),
                    y: Math.min(state.rectStart.y, my),
                    w: Math.abs(mx - state.rectStart.x),
                    h: Math.abs(my - state.rectStart.y)
                };

                // ç»˜åˆ¶ä¸´æ—¶è±å½¢é€‰æ¡†
                ctx.strokeStyle = '#10b981'; // emerald color
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                drawDiamond(ctx, tempRect.x, tempRect.y, tempRect.w, tempRect.h);
                ctx.setLineDash([]);
            }

            // ç»˜åˆ¶å·²æœ‰çš„é€‰æ¡†
            drawWatermarkRects(ctx);
        });

        window.addEventListener('mouseup', (e) => {
            if (state.isDrawingRect && tempRect && tempRect.w > 5 && tempRect.h > 5) {
                const img = state.currentImage;
                if (img) {
                    // å½’ä¸€åŒ–å­˜å‚¨ - å•æ¡†æ¨¡å¼
                    state.watermarkRect = {
                        x: tempRect.x / img.width,
                        y: tempRect.y / img.height,
                        w: tempRect.w / img.width,
                        h: tempRect.h / img.height
                    };
                    updateWatermarkStatus();
                }
            }

            state.isDrawingRect = false;
            isDraggingCrop = false;
            tempRect = null;
            if (state.currentImage) render();
        });

        // ç»˜åˆ¶è±å½¢è¾…åŠ©å‡½æ•°
        function drawDiamond(ctx, x, y, w, h) {
            const cx = x + w / 2;
            const cy = y + h / 2;
            ctx.beginPath();
            ctx.moveTo(cx, y);           // ä¸Šé¡¶ç‚¹
            ctx.lineTo(x + w, cy);       // å³é¡¶ç‚¹
            ctx.lineTo(cx, y + h);       // ä¸‹é¡¶ç‚¹
            ctx.lineTo(x, cy);           // å·¦é¡¶ç‚¹
            ctx.closePath();
            ctx.stroke();
        }

        // ç»˜åˆ¶å·²å­˜åœ¨çš„å»æ°´å°è±å½¢é€‰æ¡† (å•æ¡†æ¨¡å¼)
        function drawWatermarkRects(ctx) {
            const img = state.currentImage;
            if (!img || !state.watermarkRect) return;

            // ç»˜åˆ¶æ°´å°è±å½¢æ¡†ï¼ˆç»¿è‰²ï¼‰
            const rect = {
                x: state.watermarkRect.x * img.width,
                y: state.watermarkRect.y * img.height,
                w: state.watermarkRect.w * img.width,
                h: state.watermarkRect.h * img.height
            };
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            drawDiamond(ctx, rect.x, rect.y, rect.w, rect.h);

            // æ ‡æ³¨ - æ”¾åœ¨è±å½¢ä¸­å¿ƒä¸Šæ–¹
            ctx.fillStyle = '#10b981';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('è±å½¢æ°´å°åŒºåŸŸ', rect.x + rect.w / 2, rect.y + rect.h / 2 - 5);
            ctx.textAlign = 'left'; // é‡ç½®
        }


        // === 4. ä¿å­˜é€»è¾‘ ===

        els.saveBtn.onclick = processAndSave;
        els.downloadBtn.onclick = downloadToLocal;

        // ç”Ÿæˆå¤„ç†åçš„å›¾åƒï¼ˆå…±ç”¨é€»è¾‘ï¼‰
        function generateProcessedImage() {
            if (!state.currentImage) return null;

            const img = state.currentImage;
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');

            let finalW, finalH;

            if (state.mode === 'pad') {
                const ratio = 16 / 9;
                if (img.width / img.height < ratio) {
                    finalH = img.height;
                    finalW = finalH * ratio;
                } else {
                    finalW = img.width;
                    finalH = finalW / ratio;
                }

                offCanvas.width = finalW;
                offCanvas.height = finalH;

                const pixel = els.ctxMain.getImageData(0, 0, 1, 1).data;
                offCtx.fillStyle = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
                offCtx.fillRect(0, 0, finalW, finalH);

                const dx = (finalW - img.width) / 2;
                const dy = (finalH - img.height) / 2;
                offCtx.drawImage(els.mainCanvas, dx, dy);
            } else {
                offCanvas.width = state.cropRect.w;
                offCanvas.height = state.cropRect.h;
                offCtx.drawImage(els.mainCanvas,
                    state.cropRect.x, state.cropRect.y, state.cropRect.w, state.cropRect.h,
                    0, 0, state.cropRect.w, state.cropRect.h
                );
            }

            return offCanvas;
        }

        // ä¸‹è½½åˆ°æœ¬åœ°ï¼ˆå•æ–‡ä»¶æ¨¡å¼ï¼‰
        async function downloadToLocal() {
            const offCanvas = generateProcessedImage();
            if (!offCanvas) return;

            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, state.outputFormat, state.outputQuality));

                // æ ¹æ®æ ¼å¼ä¿®æ”¹æ‰©å±•å
                const ext = state.outputFormat === 'image/png' ? '.png' : '.jpg';
                const filename = state.currentFileName.replace(/\.[^.]+$/, `_processed${ext}`);

                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast(`å·²ä¸‹è½½: ${filename}`);
            } catch (err) {
                console.error(err);
                alert("ä¸‹è½½å¤±è´¥");
            }
        }

        // æ£€æµ‹è¾“å‡ºç›®å½•ä¸­çš„é‡å¤æ–‡ä»¶
        async function scanOutputDirectory() {
            if (!state.outputHandle) return new Set();

            const existingFiles = new Set();
            try {
                for await (const entry of state.outputHandle.values()) {
                    if (entry.kind === 'file') {
                        // å­˜å‚¨ä¸å¸¦æ‰©å±•åçš„æ–‡ä»¶åï¼Œä»¥ä¾¿åŒ¹é…ä¸åŒæ ¼å¼
                        const baseName = entry.name.replace(/\.[^.]+$/, '');
                        existingFiles.add(baseName);
                    }
                }
            } catch (err) {
                console.error('æ‰«æè¾“å‡ºç›®å½•å¤±è´¥:', err);
            }
            return existingFiles;
        }

        // æ›´æ–°æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤ºï¼ˆæ ‡è®°å·²å¤„ç†çš„æ–‡ä»¶ï¼‰
        async function updateFileListWithDuplicates() {
            const existingFiles = await scanOutputDirectory();
            state.processedFiles = existingFiles;

            const items = els.fileList.children;
            for (let i = 0; i < state.files.length; i++) {
                const baseName = state.files[i].name.replace(/\.[^.]+$/, '');
                const li = items[i];
                if (li && existingFiles.has(baseName)) {
                    // æ ‡è®°ä¸ºå·²å¤„ç†
                    if (!li.querySelector('.duplicate-mark')) {
                        const mark = document.createElement('span');
                        mark.className = 'duplicate-mark text-emerald-400 ml-1';
                        mark.textContent = 'âœ“';
                        mark.title = 'å·²å­˜åœ¨äºè¾“å‡ºç›®å½•';
                        li.appendChild(mark);
                    }
                }
            }

            return existingFiles;
        }

        // ä¿å­˜åˆ°è¾“å‡ºç›®å½•ï¼ˆæ‰¹é‡æ¨¡å¼ï¼‰
        async function processAndSave() {
            // å•æ–‡ä»¶æ¨¡å¼ç›´æ¥ä¸‹è½½
            if (state.isSingleFileMode) {
                await downloadToLocal();
                return;
            }

            if (!state.currentImage) return;

            // å¦‚æœæ²¡æœ‰è¾“å‡ºç›®å½•Handleï¼Œåˆ™ä½¿ç”¨ä¸‹è½½æ¨¡å¼
            if (!state.outputHandle) {
                await downloadToLocal();
                // æ‰¹é‡æ¨¡å¼ä¸‹è‡ªåŠ¨åˆ‡åˆ°ä¸‹ä¸€å¼ 
                if (!state.isSingleFileMode) {
                    if (state.currentIndex < state.files.length - 1) {
                        loadFile(state.currentIndex + 1);
                    } else {
                        showToast("æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæ¯•ï¼");
                    }
                }
                return;
            }

            // è¿™é‡Œä¸éœ€è¦å†å¼ºè¡Œæ‹¦æˆª outputHandleï¼Œå› ä¸ºå·²ç»å…è®¸ä¸ºç©ºäº†

            const offCanvas = generateProcessedImage();
            if (!offCanvas) return;

            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, state.outputFormat, state.outputQuality));

                // æ ¹æ®æ ¼å¼ä¿®æ”¹æ‰©å±•å
                const ext = state.outputFormat === 'image/png' ? '.png' : '.jpg';
                // æ‰¹é‡ä¿å­˜é€šå¸¸ä¿æŒåŸæ–‡ä»¶åï¼Œä½†å¯èƒ½éœ€è¦æ”¹åç¼€
                let filename = state.files[state.currentIndex].name;
                if (!filename.endsWith(ext)) {
                    filename = filename.replace(/\.[^.]+$/, ext);
                }

                const newFileHandle = await state.outputHandle.getFileHandle(filename, { create: true });
                const writable = await newFileHandle.createWritable();
                await writable.write(blob);
                await writable.close();

                showToast(`å·²ä¿å­˜: ${filename}`);

                if (state.currentIndex < state.files.length - 1) {
                    loadFile(state.currentIndex + 1);
                } else {
                    showToast("æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæ¯•ï¼");
                }
            } catch (err) {
                console.error(err);
                alert("ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç›®å½•æƒé™");
            }
        }

        // === è¾…åŠ© ===

        function showToast(msg) {
            // Update to use flex/hidden instead of display block
            els.toast.innerHTML = `<i class="fas fa-info-circle text-blue-400"></i> <span>${msg}</span>`;
            els.toast.classList.remove('hidden');
            // Assuming default display is flex due to class="... flex ..." in HTML
            setTimeout(() => els.toast.classList.add('hidden'), 2000);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') loadFile(state.currentIndex + 1);
            if (e.key === 'ArrowLeft') loadFile(state.currentIndex - 1);
            if (e.key.toLowerCase() === 's') processAndSave();
            if (e.key.toLowerCase() === 'o') saveOriginal();
            if (e.key.toLowerCase() === 'g') applyGeminiWatermarkRemoval();
            if (e.key.toLowerCase() === 'c') {
                // å¿«æ·é”®æ¸…é™¤é€‰æ¡†
                state.watermarkRect = null;
                updateWatermarkStatus();
                render();
            }
        });

        // ä¿å­˜åŸå›¾ï¼ˆè·³è¿‡å¤„ç†ï¼‰
        els.saveOriginalBtn.onclick = saveOriginal;

        async function saveOriginal() {
            if (!state.currentImage) return;

            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶ç”»å¸ƒç»˜åˆ¶åŸå›¾ï¼ˆä¸åº”ç”¨å»æ°´å°ï¼‰
            const img = state.currentImage;
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');

            let finalW, finalH;
            if (state.mode === 'pad') {
                const ratio = 16 / 9;
                if (img.width / img.height < ratio) {
                    finalH = img.height;
                    finalW = finalH * ratio;
                } else {
                    finalW = img.width;
                    finalH = finalW / ratio;
                }
                offCanvas.width = finalW;
                offCanvas.height = finalH;

                // ä»åŸå›¾å·¦ä¸Šè§’é‡‡æ ·èƒŒæ™¯è‰²
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                const pixel = tempCtx.getImageData(0, 0, 1, 1).data;
                offCtx.fillStyle = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
                offCtx.fillRect(0, 0, finalW, finalH);

                const dx = (finalW - img.width) / 2;
                const dy = (finalH - img.height) / 2;
                offCtx.drawImage(img, dx, dy);
            } else {
                offCanvas.width = state.cropRect.w;
                offCanvas.height = state.cropRect.h;

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                offCtx.drawImage(tempCanvas,
                    state.cropRect.x, state.cropRect.y, state.cropRect.w, state.cropRect.h,
                    0, 0, state.cropRect.w, state.cropRect.h
                );
            }

            // ä¿å­˜
            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, state.outputFormat, state.outputQuality));
                const ext = state.outputFormat === 'image/png' ? '.png' : '.jpg';
                let filename = state.currentFileName.replace(/\.[^.]+$/, ext);

                if (state.outputHandle) {
                    const newFileHandle = await state.outputHandle.getFileHandle(filename, { create: true });
                    const writable = await newFileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    showToast(`å·²ä¿å­˜åŸå›¾: ${filename}`);
                } else {
                    // ä¸‹è½½æ¨¡å¼
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast(`å·²ä¸‹è½½åŸå›¾: ${filename}`);
                }

                // åˆ‡æ¢åˆ°ä¸‹ä¸€å¼ 
                if (!state.isSingleFileMode && state.currentIndex < state.files.length - 1) {
                    loadFile(state.currentIndex + 1);
                } else if (!state.isSingleFileMode) {
                    showToast("æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæ¯•ï¼");
                }
            } catch (err) {
                console.error(err);
                alert("ä¿å­˜å¤±è´¥");
            }
        }

        // æ›´æ–°æ–‡ä»¶åæ˜¾ç¤º
        function updateFilenameDisplay() {
            const el = document.getElementById('current-filename');
            if (el && state.currentFileName) {
                el.textContent = state.currentFileName;
            } else if (el) {
                el.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
            }
        }

    </script>
</body>

</html>