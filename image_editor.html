<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾ç‰‡å¤„ç† - LocalForge</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Global Styles -->
    <link rel="stylesheet" href="css/style.css">
    <style>
        body {
            overflow: hidden;
        }
    </style>
    <!-- Custom Components -->
    <script type="module" src="js/components.js"></script>
</head>

<body class="bg-slate-900 text-slate-200 font-sans h-screen flex overflow-hidden">

    <local-sidebar></local-sidebar>

    <div class="flex-1 flex flex-col min-w-0">
        <!-- Header -->
        <local-header title="å›¾ç‰‡å¤„ç†å·¥å…·">
            <i slot="icon" class="fas fa-image text-blue-500"></i>
            <div slot="actions" class="text-xs text-slate-500">16:9 è£å‰ª & å»æ°´å°</div>
        </local-header>

        <!-- Main Content -->
        <div class="flex-1 flex overflow-hidden">

            <!-- Left Sidebar: File List -->
            <aside class="w-64 bg-slate-800 border-r border-slate-700 flex flex-col shrink-0 z-10">
                <div class="p-4 border-b border-slate-700">
                    <h3 class="text-sm font-bold text-slate-400 mb-3 uppercase tracking-wider">èµ„æºç®¡ç†å™¨</h3>
                    <div class="flex gap-2 mb-2">
                        <button id="btn-single"
                            class="flex-1 px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-xs text-white transition border border-slate-600 hover:border-slate-500">ğŸ“„
                            å•æ–‡ä»¶</button>
                        <button id="btn-input"
                            class="flex-1 px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-xs text-white transition border border-slate-600 hover:border-slate-500">ğŸ“‚
                            ç›®å½•</button>
                    </div>
                    <button id="btn-output"
                        class="w-full px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-xs text-blue-400 hover:text-blue-300 transition border border-slate-600 hover:border-slate-500 hidden mb-1">ğŸ’¾
                        é€‰æ‹©è¾“å‡ºç›®å½•</button>
                    <div id="output-info" class="text-[10px] text-slate-500 truncate mt-1">é»˜è®¤: Downloads</div>
                </div>

                <ul id="file-list" class="flex-1 overflow-y-auto p-2 space-y-1">
                    <li
                        class="p-4 text-center text-slate-500 text-xs border border-dashed border-slate-700 rounded select-none">
                        è¯·é€‰æ‹©æ–‡ä»¶æˆ–ç›®å½•</li>
                </ul>

                <div class="p-2 border-t border-slate-700 text-center text-[10px] text-slate-500" id="file-count">0 å¼ å›¾ç‰‡
                </div>
            </aside>

            <!-- Center: Canvas -->
            <main class="flex-1 bg-slate-900/50 flex flex-col relative overflow-hidden">
                <!-- Filename Display -->
                <div id="filename-bar"
                    class="h-10 bg-slate-800/90 border-b border-slate-700 flex items-center justify-center px-4 shrink-0">
                    <span id="current-filename"
                        class="text-sm font-medium text-blue-400 truncate max-w-full">æœªé€‰æ‹©æ–‡ä»¶</span>
                </div>
                <div
                    class="flex-1 flex items-center justify-center p-8 overflow-hidden bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTAgMGgxMHYxMEgwem0xMCAxMGgxMHYxMEgxMHoiIGZpbGw9IiMzMzMiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+')]">
                    <div id="canvas-wrapper"
                        class="relative shadow-2xl shadow-black/50 border border-slate-700/50 bg-[#111]">
                        <canvas id="main-canvas" class="block max-w-full max-h-[75vh]"></canvas>
                        <canvas id="interaction-layer"
                            class="absolute top-0 left-0 w-full h-full cursor-crosshair touch-none"></canvas>
                    </div>
                </div>

                <!-- Toast -->
                <div id="toast"
                    class="absolute top-14 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-4 py-2 rounded-full text-xs shadow-xl border border-slate-700 hidden transition-opacity z-50 flex items-center gap-2">
                    <i class="fas fa-info-circle text-blue-400"></i> <span>æç¤ºæ¶ˆæ¯</span>
                </div>
            </main>

            <!-- Right Toolbar -->
            <aside class="w-72 bg-slate-800 border-l border-slate-700 flex flex-col shrink-0 overflow-y-auto z-10">
                <div class="p-4 space-y-6">

                    <!-- Crop Mode -->
                    <div class="space-y-3">
                        <h4 class="text-xs font-bold text-slate-400 uppercase tracking-wider">æ¨¡å¼é€‰æ‹©</h4>
                        <div class="bg-slate-900/50 p-3 rounded-lg border border-slate-700/50 space-y-2">
                            <label class="flex items-center gap-3 cursor-pointer group">
                                <input type="radio" name="crop-mode" value="pad" checked
                                    class="accent-blue-500 w-4 h-4">
                                <div>
                                    <div class="text-sm font-medium text-slate-200 group-hover:text-white">å¡«å……æ¨¡å¼ (Pad)
                                    </div>
                                    <div class="text-[10px] text-slate-500">ä¸¤è¾¹å¡«å……èƒŒæ™¯ï¼Œä¿æŒå®Œæ•´ç”»é¢</div>
                                </div>
                            </label>
                            <div class="h-px bg-slate-700/50 my-1"></div>
                            <label class="flex items-center gap-3 cursor-pointer group">
                                <input type="radio" name="crop-mode" value="crop" class="accent-blue-500 w-4 h-4">
                                <div>
                                    <div class="text-sm font-medium text-slate-200 group-hover:text-white">è£å‰ªæ¨¡å¼ (Crop)
                                    </div>
                                    <div class="text-[10px] text-slate-500">è‡ªç”±æ‹–åŠ¨é€‰æ¡†æˆªå–å±€éƒ¨</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Watermark -->
                    <div class="space-y-3">
                        <h4 class="text-xs font-bold text-slate-400 uppercase tracking-wider">å»æ°´å° (è±å½¢æ¨¡å¼)</h4>
                        <div class="bg-slate-900/50 p-3 rounded-lg border border-slate-700/50">
                            <div class="text-[10px] text-slate-500 mb-3 space-y-1">
                                <p>ç»˜åˆ¶è±å½¢æ¡†é€‰ä¸­æ°´å°åŒºåŸŸ</p>
                                <p>é€‚é… Gemini ç”Ÿæˆçš„è±å½¢æ°´å°</p>
                            </div>

                            <div id="watermark-status"
                                class="px-3 py-2 bg-slate-800 rounded border border-slate-700 text-xs text-center mb-3">
                                ç­‰å¾…ç»˜åˆ¶è±å½¢...
                            </div>

                            <button id="btn-clear-mask"
                                class="w-full py-1.5 bg-slate-700 hover:bg-slate-600 text-slate-300 hover:text-white text-xs rounded border border-slate-600 transition">
                                æ¸…é™¤é€‰æ¡† (C)
                            </button>

                            <div class="mt-3 pt-3 border-t border-slate-700/50">
                                <label class="flex items-center gap-2 cursor-pointer">
                                    <input type="checkbox" id="chk-persist-mask" checked
                                        class="rounded border-slate-600 bg-slate-700 text-blue-500">
                                    <span class="text-xs font-medium text-slate-300">ä¿ç•™é€‰æ¡†ä½ç½®</span>
                                </label>
                                <p class="text-[10px] text-slate-500 mt-1 pl-5">åˆ‡æ¢å›¾ç‰‡æ—¶è‡ªåŠ¨åº”ç”¨å»æ°´å°</p>
                            </div>
                        </div>
                    </div>

                    <!-- Export -->
                    <div class="space-y-3">
                        <h4 class="text-xs font-bold text-slate-400 uppercase tracking-wider">è¾“å‡ºè®¾ç½®</h4>
                        <div class="bg-slate-900/50 p-3 rounded-lg border border-slate-700/50 space-y-3">
                            <div class="flex items-center justify-between">
                                <span class="text-xs text-slate-400">æ ¼å¼</span>
                                <select id="sel-format"
                                    class="bg-slate-800 border border-slate-600 text-xs text-white rounded px-2 py-1 outline-none focus:border-blue-500">
                                    <option value="image/jpeg">JPEG (ä½“ç§¯å°)</option>
                                    <option value="image/png">PNG (æ— æŸ)</option>
                                </select>
                            </div>
                            <div id="quality-wrapper" class="space-y-1">
                                <div class="flex justify-between text-xs text-slate-400">
                                    <span>è´¨é‡</span>
                                    <span id="quality-val" class="text-blue-400">95%</span>
                                </div>
                                <input type="range" id="rng-quality" min="10" max="100" value="95" step="5"
                                    class="w-full h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                            </div>
                        </div>
                    </div>

                    <!-- Actions -->
                    <div class="pt-4 border-t border-slate-700 space-y-3">
                        <button id="btn-save"
                            class="w-full py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-lg shadow-lg shadow-blue-500/20 transition flex items-center justify-center gap-2">
                            <span>ğŸ’¾</span> ä¿å­˜å¹¶ä¸‹ä¸€å¼  (S)
                        </button>
                        <button id="btn-save-original"
                            class="w-full py-2 bg-amber-600 hover:bg-amber-500 text-white text-xs rounded border border-amber-500 transition flex items-center justify-center gap-1">
                            <i class="fas fa-image"></i> ä¿å­˜åŸå›¾ (O)
                        </button>
                        <button id="btn-download"
                            class="w-full py-2 bg-slate-700 hover:bg-slate-600 text-white text-xs rounded border border-slate-600 hidden transition">
                            â¬‡ï¸ ä¸‹è½½åˆ°æœ¬åœ°
                        </button>
                    </div>

                    <div class="text-[10px] text-slate-600 text-center space-y-1 pb-4">
                        <p>â† / â†’ : åˆ‡æ¢å›¾ç‰‡</p>
                        <p>S : ä¿å­˜ | O : ä¿å­˜åŸå›¾ | C : æ¸…é™¤</p>
                    </div>

                </div>
            </aside>
        </div>
    </div>

    <!-- Hidden Inputs -->
    <input type="file" id="fallback-file" style="display: none;" accept="image/png, image/jpeg, image/webp">
    <input type="file" id="fallback-dir" style="display: none;" webkitdirectory directory multiple>

    <script>
        // === çŠ¶æ€ç®¡ç† ===
        const state = {
            inputHandle: null,
            outputHandle: null,
            files: [], // { name, handle }
            currentIndex: -1,
            currentImage: null, // Image Object
            currentFileName: '', // å½“å‰æ–‡ä»¶å
            isSingleFileMode: false, // å•æ–‡ä»¶æ¨¡å¼
            mode: 'pad', // 'pad' or 'crop'
            outputFormat: 'image/jpeg',
            outputQuality: 0.95,
            cropRect: { x: 0, y: 0, w: 0, h: 0 }, // è£å‰ªæ¨¡å¼ä¸‹çš„é€‰æ¡†
            // å»æ°´å°å•æ¡†æ¨¡å¼
            watermarkRect: null, // { x, y, w, h } - å½’ä¸€åŒ–åæ ‡ (0-1)
            isDrawingRect: false,
            rectStart: { x: 0, y: 0 },
        };

        // DOM å…ƒç´ 
        const els = {
            singleBtn: document.getElementById('btn-single'),
            inputBtn: document.getElementById('btn-input'),
            outputBtn: document.getElementById('btn-output'),
            downloadBtn: document.getElementById('btn-download'),
            fileList: document.getElementById('file-list'),
            fileCount: document.getElementById('file-count'),
            mainCanvas: document.getElementById('main-canvas'),
            layerCanvas: document.getElementById('interaction-layer'),
            ctxMain: document.getElementById('main-canvas').getContext('2d'),
            ctxLayer: document.getElementById('interaction-layer').getContext('2d'),
            radioModes: document.getElementsByName('crop-mode'),
            clearMaskBtn: document.getElementById('btn-clear-mask'),
            persistChk: document.getElementById('chk-persist-mask'),
            saveBtn: document.getElementById('btn-save'),
            saveOriginalBtn: document.getElementById('btn-save-original'),
            toast: document.getElementById('toast'),
            watermarkStatus: document.getElementById('watermark-status'),
            fallbackFile: document.getElementById('fallback-file'),
            fallbackDir: document.getElementById('fallback-dir'),
            selFormat: document.getElementById('sel-format'),
            rngQuality: document.getElementById('rng-quality'),
            qualityVal: document.getElementById('quality-val'),
            qualityWrapper: document.getElementById('quality-wrapper'),
            outputInfo: document.getElementById('output-info')
        };

        // === 0. è¾“å‡ºè®¾ç½® ===
        els.selFormat.onchange = (e) => {
            state.outputFormat = e.target.value;
            // PNG æ— æŸï¼Œä¸éœ€è¦è´¨é‡æ»‘å—
            if (state.outputFormat === 'image/png') {
                els.qualityWrapper.style.opacity = '0.5';
                els.qualityWrapper.style.pointerEvents = 'none';
            } else {
                els.qualityWrapper.style.opacity = '1';
                els.qualityWrapper.style.pointerEvents = 'auto';
            }
        };

        els.rngQuality.oninput = (e) => {
            const val = parseInt(e.target.value);
            els.qualityVal.textContent = val + '%';
            state.outputQuality = val / 100;
        };

        // === 1. æ–‡ä»¶ç³»ç»Ÿæ“ä½œä¸å…¼å®¹æ€§å¤„ç† ===

        // å•æ–‡ä»¶æ¨¡å¼ç‚¹å‡»
        els.singleBtn.onclick = async () => {
            if ('showOpenFilePicker' in window) {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'å›¾ç‰‡æ–‡ä»¶',
                            accept: { 'image/*': ['.jpg', '.jpeg', '.png', '.webp'] }
                        }],
                        multiple: false
                    });
                    await loadSingleFile(fileHandle);
                } catch (err) {
                    // SecurityError means we are in a context that blocks the API (e.g. iframe)
                    if (err.name === 'SecurityError' || err.name === 'NotAllowedError') {
                        els.fallbackFile.click();
                    } else if (err.name !== 'AbortError') {
                        console.error(err);
                    }
                }
            } else {
                // å›é€€æ¨¡å¼
                els.fallbackFile.click();
            }
        };

        // ç›®å½•æ¨¡å¼ç‚¹å‡»
        els.inputBtn.onclick = async () => {
            if ('showDirectoryPicker' in window) {
                try {
                    state.inputHandle = await window.showDirectoryPicker();
                    setupBatchModeUI();
                    await loadFileList();
                } catch (err) {
                    // SecurityError means we are in a context that blocks the API
                    if (err.name === 'SecurityError' || err.name === 'NotAllowedError') {
                        els.fallbackDir.click();
                    } else if (err.name !== 'AbortError') {
                        console.error(err);
                    }
                }
            } else {
                // å›é€€æ¨¡å¼
                els.fallbackDir.click();
            }
        };

        els.outputBtn.onclick = async () => {
            // è¾“å‡ºç›®å½•å¿…é¡»ä½¿ç”¨ API (fallback æ¨¡å¼ä¸‹ä¸æ”¯æŒæŒ‡å®šç›®å½•)
            try {
                const handle = await window.showDirectoryPicker();
                state.outputHandle = handle;
                els.outputInfo.textContent = `è¾“å‡ºç›®å½•: ${handle.name}`;
                els.outputInfo.style.color = '#4a90e2';
                showToast("è¾“å‡ºç›®å½•å·²è®¾å®š");
            } catch (err) {
                if (err.name === 'SecurityError' || err.name === 'NotAllowedError') {
                    // æƒé™è¢«æ‹’ç»æˆ–è¢« iframe ç­–ç•¥é˜»æ­¢
                    const msg = "âš ï¸ ç³»ç»Ÿæç¤ºï¼šæ— æ³•é€‰æ‹©è‡ªå®šä¹‰æ–‡ä»¶å¤¹\n\n" +
                        "åŸå› ï¼šå½“å‰è¿è¡Œç¯å¢ƒï¼ˆå¦‚ VS Code é¢„è§ˆçª—å£ï¼‰å› å®‰å…¨ç­–ç•¥ç¦æ­¢äº†æ­¤åŠŸèƒ½ã€‚\n\n" +
                        "ğŸ‘‰ è§£å†³æ–¹æ³•ï¼šè¯·åœ¨ Chrome æˆ– Edge æµè§ˆå™¨ä¸­ç›´æ¥æ‰“å¼€æ­¤ .html æ–‡ä»¶ï¼Œå³å¯è§£é™¤é™åˆ¶ã€‚\n\n" +
                        "ï¼ˆå½“å‰æ–‡ä»¶å°†è‡ªåŠ¨ä¿å­˜åˆ°æ‚¨çš„é»˜è®¤ã€ä¸‹è½½ã€‘æ–‡ä»¶å¤¹ï¼‰";
                    alert(msg);

                    // éšè—æŒ‰é’®ä»¥é¿å…å†æ¬¡æŠ¥é”™
                    els.outputBtn.style.display = 'none';
                    els.outputInfo.textContent = 'ä¿å­˜ä½ç½®ï¼šæµè§ˆå™¨é»˜è®¤ Downloads (ç¯å¢ƒé™åˆ¶)';
                    state.outputHandle = null; // ç¡®ä¿æ¸…é™¤
                } else if (err.name !== 'AbortError') {
                    console.error(err);
                }
            }
        };

        // ç›‘å¬å›é€€è¾“å…¥æ¡†å˜åŒ–
        els.fallbackFile.onchange = (e) => {
            const file = e.target.files[0];
            if (file) loadSingleFile(file);
            e.target.value = ''; // é‡ç½®ä»¥ä¾¿é‡å¤é€‰æ‹©
        };

        els.fallbackDir.onchange = (e) => {
            if (e.target.files && e.target.files.length > 0) {
                // å°† FileList è½¬ä¸ºæ•°ç»„å­˜å‚¨
                state.inputHandle = Array.from(e.target.files);
                setupBatchModeUI();
                loadFileList(); // åŠ è½½åˆ—è¡¨
            }
            e.target.value = '';
        };

        function setupBatchModeUI() {
            state.isSingleFileMode = false;

            // æ£€æŸ¥æ˜¯å¦æ”¯æŒ DirectoryPicker ä»¥å†³å®šæ˜¯å¦æ˜¾ç¤ºé€‰æ‹©è¾“å‡ºç›®å½•æŒ‰é’®
            const supportDirPicker = 'showDirectoryPicker' in window;

            if (supportDirPicker) {
                els.outputBtn.style.display = 'block';
                if (state.outputHandle) {
                    els.outputInfo.textContent = `è¾“å‡ºç›®å½•: ${state.outputHandle.name}`;
                } else {
                    els.outputInfo.textContent = 'é»˜è®¤ä¿å­˜ä½ç½®ï¼šDownloads (å¯ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®ä¿®æ”¹)';
                }
            } else {
                els.outputBtn.style.display = 'none';
                els.outputInfo.textContent = 'ä¿å­˜ä½ç½®ï¼šæµè§ˆå™¨é»˜è®¤ Downloads (ç³»ç»Ÿé™åˆ¶æ— æ³•ä¿®æ”¹)';
            }

            els.downloadBtn.style.display = 'none';
            els.saveBtn.textContent = 'ä¿å­˜å¹¶ä¸‹ä¸€å¼  (S)';
        }

        // åŠ è½½å•ä¸ªæ–‡ä»¶ (æ”¯æŒ Handle æˆ– File)
        async function loadSingleFile(fileOrHandle) {
            state.isSingleFileMode = true;
            state.files = [{
                name: fileOrHandle.name,
                handle: fileOrHandle // å¯èƒ½æ˜¯ File å¯¹è±¡æˆ– FileSystemFileHandle
            }];
            state.currentIndex = 0;
            state.currentFileName = fileOrHandle.name;
            updateFilenameDisplay();

            // æ›´æ–° UI
            els.downloadBtn.style.display = 'block';
            els.saveBtn.textContent = 'ä¿å­˜ (S)';
            els.outputInfo.textContent = 'å•æ–‡ä»¶æ¨¡å¼ï¼šä¿å­˜åˆ° Downloads';

            els.fileList.innerHTML = '';
            const li = document.createElement('li');
            li.textContent = fileOrHandle.name;
            li.classList.add('active');
            els.fileList.appendChild(li);
            els.fileCount.textContent = 'å•æ–‡ä»¶æ¨¡å¼';

            // è¯»å–
            await loadFileContent(fileOrHandle);

            // é‡ç½®é€‰æ¡†
            if (!els.persistChk.checked) {
                resetWatermark();
            }
            updateWatermarkStatus();
            initCropRect();
            render();
        }

        // ç»Ÿä¸€è¯»å–æ–‡ä»¶å†…å®¹
        async function loadFileContent(fileOrHandle) {
            let file;
            if (fileOrHandle.getFile) {
                // API Handle
                file = await fileOrHandle.getFile();
            } else {
                // Standard File object
                file = fileOrHandle;
            }
            const bmp = await createImageBitmap(file);
            state.currentImage = bmp;
        }


        function resetWatermark() {
            state.watermarkRect = null;
        }

        async function loadFileList() {
            state.files = [];
            els.fileList.innerHTML = '';

            const isApiMode = state.inputHandle && !Array.isArray(state.inputHandle);

            if (isApiMode) {
                // API æ¨¡å¼: éå† DirectoryHandle
                for await (const entry of state.inputHandle.values()) {
                    if (entry.kind === 'file' && /\.(jpg|jpeg|png|webp)$/i.test(entry.name)) {
                        state.files.push({ name: entry.name, handle: entry });
                    }
                }
            } else {
                // å›é€€æ¨¡å¼: state.inputHandle æ˜¯ File æ•°ç»„
                state.files = state.inputHandle
                    .filter(f => /\.(jpg|jpeg|png|webp)$/i.test(f.name))
                    .map(f => ({ name: f.name, handle: f }));
            }

            // æ’åº
            state.files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

            // æ¸²æŸ“åˆ—è¡¨
            state.files.forEach((f, i) => {
                const li = document.createElement('li');
                li.textContent = f.name;
                li.className = 'p-2 text-xs rounded cursor-pointer hover:bg-slate-700 truncate text-slate-300 transition-colors';
                li.onclick = () => loadFile(i);
                els.fileList.appendChild(li);
            });

            els.fileCount.textContent = `${state.files.length} å¼ å›¾ç‰‡`;
            if (state.files.length > 0) loadFile(0);
        }

        async function loadFile(index) {
            if (index < 0 || index >= state.files.length) return;

            // UI æ›´æ–°
            const items = els.fileList.children;
            if (state.currentIndex >= 0 && items[state.currentIndex]) {
                const prev = items[state.currentIndex];
                prev.classList.remove('bg-blue-600', 'text-white');
                prev.classList.add('text-slate-300');
            }
            state.currentIndex = index;
            const current = items[index];
            current.classList.remove('text-slate-300');
            current.classList.add('bg-blue-600', 'text-white');
            current.scrollIntoView({ block: 'nearest' });

            state.currentFileName = state.files[index].name;
            updateFilenameDisplay();

            // è¯»å–æ–‡ä»¶
            await loadFileContent(state.files[index].handle);

            // é®ç½©å¤„ç†
            if (!els.persistChk.checked) {
                resetWatermark();
            }
            updateWatermarkStatus();

            // åˆå§‹åŒ–è£å‰ªæ¡†
            initCropRect();

            render();
        }

        function initCropRect() {
            if (!state.currentImage) return;
            const imgW = state.currentImage.width;
            const imgH = state.currentImage.height;

            // ç›®æ ‡æ˜¯ 16:9
            // å¦‚æœæ˜¯è£å‰ªæ¨¡å¼ï¼Œåˆå§‹åŒ–ä¸€ä¸ªæœ€å¤§çš„ 16:9 æ¡†
            let targetW = imgW;
            let targetH = targetW * (9 / 16);
            if (targetH > imgH) {
                targetH = imgH;
                targetW = targetH * (16 / 9);
            }

            state.cropRect = {
                x: (imgW - targetW) / 2,
                y: (imgH - targetH) / 2,
                w: targetW,
                h: targetH
            };
        }

        // === 2. æ¸²æŸ“é€»è¾‘ ===

        // ç›‘å¬æ¨¡å¼åˆ‡æ¢
        els.radioModes.forEach(r => r.addEventListener('change', (e) => {
            state.mode = e.target.value;
            render();
        }));

        function render() {
            if (!state.currentImage) return;

            // 1. è®¾ç½®ç”»å¸ƒå°ºå¯¸
            // è¿™é‡Œçš„é€»è¾‘æ˜¯ï¼šMainCanvas å§‹ç»ˆä½œä¸º"æœ€ç»ˆè¾“å‡ºé¢„è§ˆ"
            // Pad æ¨¡å¼ä¸‹ï¼šMainCanvas æ˜¯ 16:9 çš„æ‰©å……å›¾
            // Crop æ¨¡å¼ä¸‹ï¼šMainCanvas æ˜¾ç¤ºåŸå›¾ï¼Œç”¨ InteractionLayer æ˜¾ç¤ºè£å‰ªæ¡†
            // ä¸ºäº†ç®€åŒ–ç»Ÿä¸€ï¼Œæˆ‘ä»¬åœ¨ MainCanvas ä¸Šæ€»æ˜¯ç»˜åˆ¶"æ‰€è§å³æ‰€å¾—"çš„ç»“æœä¸å¤ªå®¹æ˜“ï¼Œ
            // ç­–ç•¥ï¼šMainCanvas ç»˜åˆ¶åº•å›¾ï¼ˆåŸå›¾ï¼‰ï¼Œæˆ‘ä»¬åœ¨ä¿å­˜æ—¶å†åšçœŸæ­£çš„è£åˆ‡/å¡«å……ã€‚
            // åªæœ‰è¿™æ ·ï¼Œå»æ°´å°çš„ç¬”åˆ·åæ ‡æ‰èƒ½ç»Ÿä¸€å¯¹åº”åˆ°åŸå›¾ä¸Šã€‚

            const img = state.currentImage;
            els.mainCanvas.width = img.width;
            els.mainCanvas.height = img.height;
            els.layerCanvas.width = img.width;
            els.layerCanvas.height = img.height;

            // ç»˜åˆ¶åŸå›¾
            els.ctxMain.drawImage(img, 0, 0);

            // 2. åº”ç”¨å»æ°´å° (ç®€å•çš„å‘¨å›´å¡«å……ç®—æ³•)
            applyInpainting();

            // 3. ç»˜åˆ¶äº¤äº’å±‚ (è£å‰ªæ¡†)
            drawOverlay();
        }

        function applyInpainting() {
            // è±å½¢æ¸å˜å¡«å……ï¼šä»è±å½¢è¾¹ç¼˜é‡‡æ ·ï¼Œä½¿ç”¨åŒçº¿æ€§æ’å€¼æ¸å˜å¡«å……è±å½¢åŒºåŸŸ
            if (!state.watermarkRect) return;

            const ctx = els.ctxMain;
            const imgW = els.mainCanvas.width;
            const imgH = els.mainCanvas.height;

            // è¿˜åŸæ°´å°æ¡†åæ ‡ï¼ˆå½’ä¸€åŒ– -> åƒç´ ï¼‰
            const rect = {
                x: Math.floor(state.watermarkRect.x * imgW),
                y: Math.floor(state.watermarkRect.y * imgH),
                w: Math.floor(state.watermarkRect.w * imgW),
                h: Math.floor(state.watermarkRect.h * imgH)
            };

            // è¾¹ç•Œæ£€æŸ¥
            if (rect.w <= 0 || rect.h <= 0) return;
            if (rect.x < 0 || rect.y < 0 || rect.x + rect.w > imgW || rect.y + rect.h > imgH) return;

            // è±å½¢ä¸­å¿ƒå’ŒåŠå¾„
            const cx = rect.x + rect.w / 2;
            const cy = rect.y + rect.h / 2;
            const rx = rect.w / 2; // æ°´å¹³åŠå¾„
            const ry = rect.h / 2; // å‚ç›´åŠå¾„

            // é‡‡æ ·è¾¹è·ï¼ˆå‘å¤–æ‰©å±•é‡‡æ ·ï¼‰
            const margin = 5;

            // åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨è±å½¢å†…
            function isInsideDiamond(px, py) {
                const dx = Math.abs(px - cx) / rx;
                const dy = Math.abs(py - cy) / ry;
                return (dx + dy) <= 1.0;
            }

            // ä»è±å½¢å››ä¸ªé¡¶ç‚¹å¤–ä¾§é‡‡æ ·é¢œè‰²
            function sampleDiamondVertexColor(vertex, offsetX, offsetY) {
                const sx = Math.max(0, Math.min(imgW - 1, Math.floor(vertex.x + offsetX)));
                const sy = Math.max(0, Math.min(imgH - 1, Math.floor(vertex.y + offsetY)));
                const pixel = ctx.getImageData(sx, sy, 1, 1).data;
                return { r: pixel[0], g: pixel[1], b: pixel[2] };
            }

            // è±å½¢å››ä¸ªé¡¶ç‚¹
            const topVertex = { x: cx, y: rect.y };
            const bottomVertex = { x: cx, y: rect.y + rect.h };
            const leftVertex = { x: rect.x, y: cy };
            const rightVertex = { x: rect.x + rect.w, y: cy };

            // ä»é¡¶ç‚¹å¤–ä¾§é‡‡æ ·é¢œè‰²
            const topColor = sampleDiamondVertexColor(topVertex, 0, -margin);
            const bottomColor = sampleDiamondVertexColor(bottomVertex, 0, margin);
            const leftColor = sampleDiamondVertexColor(leftVertex, -margin, 0);
            const rightColor = sampleDiamondVertexColor(rightVertex, margin, 0);

            // ä½¿ç”¨ ImageData è¿›è¡Œé«˜æ•ˆåƒç´ æ“ä½œ
            const imageData = ctx.getImageData(rect.x, rect.y, rect.w, rect.h);
            const data = imageData.data;

            // æ¸å˜å¡«å……è±å½¢åŒºåŸŸ
            for (let py = 0; py < rect.h; py++) {
                for (let px = 0; px < rect.w; px++) {
                    const absX = rect.x + px;
                    const absY = rect.y + py;

                    // åªå¡«å……è±å½¢å†…éƒ¨çš„åƒç´ 
                    if (!isInsideDiamond(absX, absY)) continue;

                    // è®¡ç®—ç›¸å¯¹äºè±å½¢ä¸­å¿ƒçš„å½’ä¸€åŒ–ä½ç½®
                    const tx = rx > 0 ? (px - rx) / rx : 0; // -1 åˆ° 1
                    const ty = ry > 0 ? (py - ry) / ry : 0; // -1 åˆ° 1

                    // åŸºäºä½ç½®ï¼Œè®¡ç®—å››ä¸ªé¡¶ç‚¹é¢œè‰²çš„æƒé‡
                    // ä¸Š/ä¸‹æƒé‡
                    const topWeight = Math.max(0, -ty);
                    const bottomWeight = Math.max(0, ty);
                    // å·¦/å³æƒé‡
                    const leftWeight = Math.max(0, -tx);
                    const rightWeight = Math.max(0, tx);

                    // å½’ä¸€åŒ–æƒé‡
                    let totalWeight = topWeight + bottomWeight + leftWeight + rightWeight;
                    if (totalWeight === 0) totalWeight = 1;

                    // åŠ æƒæ··åˆé¢œè‰²
                    const finalR = (topColor.r * topWeight + bottomColor.r * bottomWeight +
                        leftColor.r * leftWeight + rightColor.r * rightWeight) / totalWeight;
                    const finalG = (topColor.g * topWeight + bottomColor.g * bottomWeight +
                        leftColor.g * leftWeight + rightColor.g * rightWeight) / totalWeight;
                    const finalB = (topColor.b * topWeight + bottomColor.b * bottomWeight +
                        leftColor.b * leftWeight + rightColor.b * rightWeight) / totalWeight;

                    // æ·»åŠ å¾®å°å™ªç‚¹æ¨¡æ‹Ÿè‡ªç„¶çº¹ç†
                    const noise = (Math.random() - 0.5) * 4;

                    const idx = (py * rect.w + px) * 4;
                    data[idx] = Math.max(0, Math.min(255, Math.round(finalR + noise)));
                    data[idx + 1] = Math.max(0, Math.min(255, Math.round(finalG + noise)));
                    data[idx + 2] = Math.max(0, Math.min(255, Math.round(finalB + noise)));
                }
            }

            ctx.putImageData(imageData, rect.x, rect.y);
        }

        function drawOverlay() {
            const ctx = els.ctxLayer;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // è£å‰ªæ¨¡å¼ä¸‹ç»˜åˆ¶é®ç½©
            if (state.mode === 'crop') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // æŒ–ç©ºé€‰ä¸­åŒºåŸŸ
                const { x, y, w, h } = state.cropRect;
                ctx.clearRect(x, y, w, h);

                // ç»˜åˆ¶è¾¹æ¡†
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                // ç»˜åˆ¶ä¸‰åˆ†çº¿ (è¾…åŠ©æ„å›¾)
                ctx.beginPath();
                ctx.moveTo(x + w / 3, y); ctx.lineTo(x + w / 3, y + h);
                ctx.moveTo(x + 2 * w / 3, y); ctx.lineTo(x + 2 * w / 3, y + h);
                ctx.moveTo(x, y + h / 3); ctx.lineTo(x + w, y + h / 3);
                ctx.moveTo(x, y + 2 * h / 3); ctx.lineTo(x + w, y + 2 * h / 3);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.stroke();
            } else {
                // Pad æ¨¡å¼ä¸‹ï¼Œæç¤ºæœ€ç»ˆèŒƒå›´ï¼ˆè™½ç„¶æ˜¯å…¨å›¾ï¼Œä½†ç»™ä¸ªè¾¹æ¡†æç¤ºï¼‰
                // Pad æ¨¡å¼å…¶å®ä¸éœ€è¦ overlayï¼Œé™¤éæˆ‘ä»¬æƒ³é¢„è§ˆå¡«å……åçš„æ•ˆæœ
                // ç®€å•èµ·è§ï¼ŒPad æ¨¡å¼ä¸æ˜¾ç¤ºç‰¹æ®Š Overlayï¼Œåªæ˜¾ç¤ºç¬”åˆ·
            }

            // ç»˜åˆ¶ç¬”åˆ·å…‰æ ‡ (å¦‚æœé¼ æ ‡åœ¨ç”»å¸ƒä¸Š)
            // (ç”± mousemove å¤„ç†)
        }


        // === 3. äº¤äº’é€»è¾‘ (å•æ¡†å»æ°´å° + è£å‰ª) ===

        // æ›´æ–°å»æ°´å°çŠ¶æ€æç¤º
        function updateWatermarkStatus() {
            if (!els.watermarkStatus) return;
            if (state.watermarkRect) {
                els.watermarkStatus.innerHTML = 'å½“å‰çŠ¶æ€ï¼š<span class="text-emerald-400 font-bold">âœ“ è±å½¢å»æ°´å°å·²å®Œæˆ</span>';
            } else {
                els.watermarkStatus.innerHTML = 'å½“å‰çŠ¶æ€ï¼š<span class="text-blue-400 font-bold">è¯·ç»˜åˆ¶è±å½¢</span>ï¼ˆæ¡†é€‰æ°´å°åŒºåŸŸï¼‰';
            }
        }

        // æ¸…é™¤é€‰æ¡†
        els.clearMaskBtn.onclick = () => {
            state.watermarkRect = null;
            updateWatermarkStatus();
            render();
        };

        // é¼ æ ‡äº‹ä»¶
        let isDraggingCrop = false;
        let lastMouse = { x: 0, y: 0 };
        let tempRect = null; // ä¸´æ—¶ç»˜åˆ¶çš„é€‰æ¡†

        els.layerCanvas.addEventListener('mousedown', (e) => {
            const rect = els.layerCanvas.getBoundingClientRect();
            const scaleX = els.layerCanvas.width / rect.width;
            const scaleY = els.layerCanvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            if (state.mode === 'crop') {
                // è£å‰ªæ¨¡å¼ï¼šæ‹–åŠ¨é€‰æ¡†
                if (mx >= state.cropRect.x && mx <= state.cropRect.x + state.cropRect.w &&
                    my >= state.cropRect.y && my <= state.cropRect.y + state.cropRect.h) {
                    isDraggingCrop = true;
                    lastMouse = { x: mx, y: my };
                }
            } else {
                // Pad æ¨¡å¼ï¼šå•æ¡†å»æ°´å°
                state.isDrawingRect = true;
                state.rectStart = { x: mx, y: my };
                tempRect = { x: mx, y: my, w: 0, h: 0 };
            }
        });

        els.layerCanvas.addEventListener('mousemove', (e) => {
            const rect = els.layerCanvas.getBoundingClientRect();
            const scaleX = els.layerCanvas.width / rect.width;
            const scaleY = els.layerCanvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            // é‡ç»˜äº¤äº’å±‚
            drawOverlay();
            const ctx = els.ctxLayer;

            if (state.mode === 'crop' && isDraggingCrop) {
                const dx = mx - lastMouse.x;
                const dy = my - lastMouse.y;
                state.cropRect.x += dx;
                state.cropRect.y += dy;

                // é™åˆ¶è¾¹ç•Œ
                const cw = els.layerCanvas.width;
                const ch = els.layerCanvas.height;
                if (state.cropRect.x < 0) state.cropRect.x = 0;
                if (state.cropRect.y < 0) state.cropRect.y = 0;
                if (state.cropRect.x + state.cropRect.w > cw) state.cropRect.x = cw - state.cropRect.w;
                if (state.cropRect.y + state.cropRect.h > ch) state.cropRect.y = ch - state.cropRect.h;
                lastMouse = { x: mx, y: my };
                drawOverlay();
            } else if (state.isDrawingRect && state.mode === 'pad') {
                // ç»˜åˆ¶ä¸´æ—¶é€‰æ¡†é¢„è§ˆ
                tempRect = {
                    x: Math.min(state.rectStart.x, mx),
                    y: Math.min(state.rectStart.y, my),
                    w: Math.abs(mx - state.rectStart.x),
                    h: Math.abs(my - state.rectStart.y)
                };

                // ç»˜åˆ¶ä¸´æ—¶è±å½¢é€‰æ¡†
                ctx.strokeStyle = '#10b981'; // emerald color
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                drawDiamond(ctx, tempRect.x, tempRect.y, tempRect.w, tempRect.h);
                ctx.setLineDash([]);
            }

            // ç»˜åˆ¶å·²æœ‰çš„é€‰æ¡†
            drawWatermarkRects(ctx);
        });

        window.addEventListener('mouseup', (e) => {
            if (state.isDrawingRect && tempRect && tempRect.w > 5 && tempRect.h > 5) {
                const img = state.currentImage;
                if (img) {
                    // å½’ä¸€åŒ–å­˜å‚¨ - å•æ¡†æ¨¡å¼
                    state.watermarkRect = {
                        x: tempRect.x / img.width,
                        y: tempRect.y / img.height,
                        w: tempRect.w / img.width,
                        h: tempRect.h / img.height
                    };
                    updateWatermarkStatus();
                }
            }

            state.isDrawingRect = false;
            isDraggingCrop = false;
            tempRect = null;
            if (state.currentImage) render();
        });

        // ç»˜åˆ¶è±å½¢è¾…åŠ©å‡½æ•°
        function drawDiamond(ctx, x, y, w, h) {
            const cx = x + w / 2;
            const cy = y + h / 2;
            ctx.beginPath();
            ctx.moveTo(cx, y);           // ä¸Šé¡¶ç‚¹
            ctx.lineTo(x + w, cy);       // å³é¡¶ç‚¹
            ctx.lineTo(cx, y + h);       // ä¸‹é¡¶ç‚¹
            ctx.lineTo(x, cy);           // å·¦é¡¶ç‚¹
            ctx.closePath();
            ctx.stroke();
        }

        // ç»˜åˆ¶å·²å­˜åœ¨çš„å»æ°´å°è±å½¢é€‰æ¡† (å•æ¡†æ¨¡å¼)
        function drawWatermarkRects(ctx) {
            const img = state.currentImage;
            if (!img || !state.watermarkRect) return;

            // ç»˜åˆ¶æ°´å°è±å½¢æ¡†ï¼ˆç»¿è‰²ï¼‰
            const rect = {
                x: state.watermarkRect.x * img.width,
                y: state.watermarkRect.y * img.height,
                w: state.watermarkRect.w * img.width,
                h: state.watermarkRect.h * img.height
            };
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            drawDiamond(ctx, rect.x, rect.y, rect.w, rect.h);

            // æ ‡æ³¨ - æ”¾åœ¨è±å½¢ä¸­å¿ƒä¸Šæ–¹
            ctx.fillStyle = '#10b981';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('è±å½¢æ°´å°åŒºåŸŸ', rect.x + rect.w / 2, rect.y + rect.h / 2 - 5);
            ctx.textAlign = 'left'; // é‡ç½®
        }


        // === 4. ä¿å­˜é€»è¾‘ ===

        els.saveBtn.onclick = processAndSave;
        els.downloadBtn.onclick = downloadToLocal;

        // ç”Ÿæˆå¤„ç†åçš„å›¾åƒï¼ˆå…±ç”¨é€»è¾‘ï¼‰
        function generateProcessedImage() {
            if (!state.currentImage) return null;

            const img = state.currentImage;
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');

            let finalW, finalH;

            if (state.mode === 'pad') {
                const ratio = 16 / 9;
                if (img.width / img.height < ratio) {
                    finalH = img.height;
                    finalW = finalH * ratio;
                } else {
                    finalW = img.width;
                    finalH = finalW / ratio;
                }

                offCanvas.width = finalW;
                offCanvas.height = finalH;

                const pixel = els.ctxMain.getImageData(0, 0, 1, 1).data;
                offCtx.fillStyle = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
                offCtx.fillRect(0, 0, finalW, finalH);

                const dx = (finalW - img.width) / 2;
                const dy = (finalH - img.height) / 2;
                offCtx.drawImage(els.mainCanvas, dx, dy);
            } else {
                offCanvas.width = state.cropRect.w;
                offCanvas.height = state.cropRect.h;
                offCtx.drawImage(els.mainCanvas,
                    state.cropRect.x, state.cropRect.y, state.cropRect.w, state.cropRect.h,
                    0, 0, state.cropRect.w, state.cropRect.h
                );
            }

            return offCanvas;
        }

        // ä¸‹è½½åˆ°æœ¬åœ°ï¼ˆå•æ–‡ä»¶æ¨¡å¼ï¼‰
        async function downloadToLocal() {
            const offCanvas = generateProcessedImage();
            if (!offCanvas) return;

            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, state.outputFormat, state.outputQuality));

                // æ ¹æ®æ ¼å¼ä¿®æ”¹æ‰©å±•å
                const ext = state.outputFormat === 'image/png' ? '.png' : '.jpg';
                const filename = state.currentFileName.replace(/\.[^.]+$/, `_processed${ext}`);

                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast(`å·²ä¸‹è½½: ${filename}`);
            } catch (err) {
                console.error(err);
                alert("ä¸‹è½½å¤±è´¥");
            }
        }

        // æ£€æµ‹è¾“å‡ºç›®å½•ä¸­çš„é‡å¤æ–‡ä»¶
        async function scanOutputDirectory() {
            if (!state.outputHandle) return new Set();

            const existingFiles = new Set();
            try {
                for await (const entry of state.outputHandle.values()) {
                    if (entry.kind === 'file') {
                        // å­˜å‚¨ä¸å¸¦æ‰©å±•åçš„æ–‡ä»¶åï¼Œä»¥ä¾¿åŒ¹é…ä¸åŒæ ¼å¼
                        const baseName = entry.name.replace(/\.[^.]+$/, '');
                        existingFiles.add(baseName);
                    }
                }
            } catch (err) {
                console.error('æ‰«æè¾“å‡ºç›®å½•å¤±è´¥:', err);
            }
            return existingFiles;
        }

        // æ›´æ–°æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤ºï¼ˆæ ‡è®°å·²å¤„ç†çš„æ–‡ä»¶ï¼‰
        async function updateFileListWithDuplicates() {
            const existingFiles = await scanOutputDirectory();
            state.processedFiles = existingFiles;

            const items = els.fileList.children;
            for (let i = 0; i < state.files.length; i++) {
                const baseName = state.files[i].name.replace(/\.[^.]+$/, '');
                const li = items[i];
                if (li && existingFiles.has(baseName)) {
                    // æ ‡è®°ä¸ºå·²å¤„ç†
                    if (!li.querySelector('.duplicate-mark')) {
                        const mark = document.createElement('span');
                        mark.className = 'duplicate-mark text-emerald-400 ml-1';
                        mark.textContent = 'âœ“';
                        mark.title = 'å·²å­˜åœ¨äºè¾“å‡ºç›®å½•';
                        li.appendChild(mark);
                    }
                }
            }

            return existingFiles;
        }

        // ä¿å­˜åˆ°è¾“å‡ºç›®å½•ï¼ˆæ‰¹é‡æ¨¡å¼ï¼‰
        async function processAndSave() {
            // å•æ–‡ä»¶æ¨¡å¼ç›´æ¥ä¸‹è½½
            if (state.isSingleFileMode) {
                await downloadToLocal();
                return;
            }

            if (!state.currentImage) return;

            // å¦‚æœæ²¡æœ‰è¾“å‡ºç›®å½•Handleï¼Œåˆ™ä½¿ç”¨ä¸‹è½½æ¨¡å¼
            if (!state.outputHandle) {
                await downloadToLocal();
                // æ‰¹é‡æ¨¡å¼ä¸‹è‡ªåŠ¨åˆ‡åˆ°ä¸‹ä¸€å¼ 
                if (!state.isSingleFileMode) {
                    if (state.currentIndex < state.files.length - 1) {
                        loadFile(state.currentIndex + 1);
                    } else {
                        showToast("æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæ¯•ï¼");
                    }
                }
                return;
            }

            // è¿™é‡Œä¸éœ€è¦å†å¼ºè¡Œæ‹¦æˆª outputHandleï¼Œå› ä¸ºå·²ç»å…è®¸ä¸ºç©ºäº†

            const offCanvas = generateProcessedImage();
            if (!offCanvas) return;

            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, state.outputFormat, state.outputQuality));

                // æ ¹æ®æ ¼å¼ä¿®æ”¹æ‰©å±•å
                const ext = state.outputFormat === 'image/png' ? '.png' : '.jpg';
                // æ‰¹é‡ä¿å­˜é€šå¸¸ä¿æŒåŸæ–‡ä»¶åï¼Œä½†å¯èƒ½éœ€è¦æ”¹åç¼€
                let filename = state.files[state.currentIndex].name;
                if (!filename.endsWith(ext)) {
                    filename = filename.replace(/\.[^.]+$/, ext);
                }

                const newFileHandle = await state.outputHandle.getFileHandle(filename, { create: true });
                const writable = await newFileHandle.createWritable();
                await writable.write(blob);
                await writable.close();

                showToast(`å·²ä¿å­˜: ${filename}`);

                if (state.currentIndex < state.files.length - 1) {
                    loadFile(state.currentIndex + 1);
                } else {
                    showToast("æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæ¯•ï¼");
                }
            } catch (err) {
                console.error(err);
                alert("ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç›®å½•æƒé™");
            }
        }

        // === è¾…åŠ© ===

        function showToast(msg) {
            // Update to use flex/hidden instead of display block
            els.toast.innerHTML = `<i class="fas fa-info-circle text-blue-400"></i> <span>${msg}</span>`;
            els.toast.classList.remove('hidden');
            // Assuming default display is flex due to class="... flex ..." in HTML
            setTimeout(() => els.toast.classList.add('hidden'), 2000);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') loadFile(state.currentIndex + 1);
            if (e.key === 'ArrowLeft') loadFile(state.currentIndex - 1);
            if (e.key.toLowerCase() === 's') processAndSave();
            if (e.key.toLowerCase() === 'o') saveOriginal();
            if (e.key.toLowerCase() === 'c') {
                // å¿«æ·é”®æ¸…é™¤é€‰æ¡†
                state.watermarkRect = null;
                updateWatermarkStatus();
                render();
            }
        });

        // ä¿å­˜åŸå›¾ï¼ˆè·³è¿‡å¤„ç†ï¼‰
        els.saveOriginalBtn.onclick = saveOriginal;

        async function saveOriginal() {
            if (!state.currentImage) return;

            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶ç”»å¸ƒç»˜åˆ¶åŸå›¾ï¼ˆä¸åº”ç”¨å»æ°´å°ï¼‰
            const img = state.currentImage;
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');

            let finalW, finalH;
            if (state.mode === 'pad') {
                const ratio = 16 / 9;
                if (img.width / img.height < ratio) {
                    finalH = img.height;
                    finalW = finalH * ratio;
                } else {
                    finalW = img.width;
                    finalH = finalW / ratio;
                }
                offCanvas.width = finalW;
                offCanvas.height = finalH;

                // ä»åŸå›¾å·¦ä¸Šè§’é‡‡æ ·èƒŒæ™¯è‰²
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                const pixel = tempCtx.getImageData(0, 0, 1, 1).data;
                offCtx.fillStyle = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
                offCtx.fillRect(0, 0, finalW, finalH);

                const dx = (finalW - img.width) / 2;
                const dy = (finalH - img.height) / 2;
                offCtx.drawImage(img, dx, dy);
            } else {
                offCanvas.width = state.cropRect.w;
                offCanvas.height = state.cropRect.h;

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                offCtx.drawImage(tempCanvas,
                    state.cropRect.x, state.cropRect.y, state.cropRect.w, state.cropRect.h,
                    0, 0, state.cropRect.w, state.cropRect.h
                );
            }

            // ä¿å­˜
            try {
                const blob = await new Promise(r => offCanvas.toBlob(r, state.outputFormat, state.outputQuality));
                const ext = state.outputFormat === 'image/png' ? '.png' : '.jpg';
                let filename = state.currentFileName.replace(/\.[^.]+$/, ext);

                if (state.outputHandle) {
                    const newFileHandle = await state.outputHandle.getFileHandle(filename, { create: true });
                    const writable = await newFileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    showToast(`å·²ä¿å­˜åŸå›¾: ${filename}`);
                } else {
                    // ä¸‹è½½æ¨¡å¼
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast(`å·²ä¸‹è½½åŸå›¾: ${filename}`);
                }

                // åˆ‡æ¢åˆ°ä¸‹ä¸€å¼ 
                if (!state.isSingleFileMode && state.currentIndex < state.files.length - 1) {
                    loadFile(state.currentIndex + 1);
                } else if (!state.isSingleFileMode) {
                    showToast("æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæ¯•ï¼");
                }
            } catch (err) {
                console.error(err);
                alert("ä¿å­˜å¤±è´¥");
            }
        }

        // æ›´æ–°æ–‡ä»¶åæ˜¾ç¤º
        function updateFilenameDisplay() {
            const el = document.getElementById('current-filename');
            if (el && state.currentFileName) {
                el.textContent = state.currentFileName;
            } else if (el) {
                el.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
            }
        }

    </script>
</body>

</html>